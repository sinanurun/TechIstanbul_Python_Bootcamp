# -*- coding: utf-8 -*-
"""oturum03_01Kasim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G1FWlCefPKSCH_vm-W2DGsvgl4NEgmUJ

#axis parametesi

**Axis Nedir?**

Axis, bir dizide işlem yapılacak boyutu/ekseni ifade eder.

* Axis 0 (satırlar boyunca işlem)
→ Sütunlar üzerinde işlem yapılır
(Yani her sütun için işlem yapılır)

* Axis 1 (sütırlar üzerinde işlem)
→ Satırlar üzerinde işlem yapılır
(Yani her satır için işlem yapılır)

Matrix:  
[[ 1  2  3  4]   ← axis=1 → [1+2+3+4 = 10]  
 [ 5  6  7  8]   ← axis=1 → [5+6+7+8 = 26]    
 [ 9 10 11 12]]  ← axis=1 → [9+10+11+12 = 42]  

  ↑  ↑  ↑  ↑  
  |  |  |  |  
  ↓  ↓  ↓  ↓  
  [15,18,21,24]
"""

import numpy as np

# 3x4'lük örnek matrix
matrix = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])

print("Orijinal matrix:\n", matrix)
print("shape:", matrix.shape)  # (3, 4)

# axis=0: Sütunlar boyunca (her sütundan bir değer)
print("axis=0 (sütunlar boyunca):")
print("Sum:", np.sum(matrix, axis=0))    # [1+5+9, 2+6+10, 3+7+11, 4+8+12] = [15, 18, 21, 24]
print("Mean:", np.mean(matrix, axis=0))  # [5, 6, 7, 8]

# axis=1: Satırlar boyunca (her satırdan bir değer)
print("axis=1 (satırlar boyunca):")
print("Sum:", np.sum(matrix, axis=1))    # [1+2+3+4, 5+6+7+8, 9+10+11+12] = [10, 26, 42]
print("Mean:", np.mean(matrix, axis=1))  # [2.5, 6.5, 10.5]

"""#Dizilerde Toplama sum"""

import numpy as np

# Basit bir dizi oluşturalım
a = np.array([1, 2, 3, 4, 5])
print("Dizi:", a)

# Tüm elemanların toplamı
toplam = np.sum(a)
print("Toplam:", toplam)  # Çıktı: 15

# 2 boyutlu dizi örneği
b = np.array([[1, 2, 3],
              [4, 5, 6]])

print("2D dizi:\n", b)

# Tüm elemanların toplamı
print("Tüm elemanların toplamı:", np.sum(b))  # 21

# Satırların toplamı (axis=1)
print("Satır toplamları:", np.sum(b, axis=1))  # [6, 15]

# Sütunların toplamı (axis=0)
print("Sütun toplamları:", np.sum(b, axis=0))  # [5, 7, 9]

#np.sum() fonksiyonu, bir dizideki tüm elemanların toplamını verir.
#Çok boyutlu dizilerde eksen (axis) belirleyerek
#satır veya sütun bazında da toplam alabilirsiniz.

#axis=0 → sütunlar boyunca işlem yapar (yani satırlar birleştirilir)
#axis=1 → satırlar boyunca işlem yapar (yani sütunlar birleştirilir)

"""# ortalama hesaplama mean

Not: Ortalama, toplam / eleman sayısı formülüyle hesaplanır. np.mean() otomatik olarak bunu yapar.
"""

# Aynı diziyi kullanalım
a = np.array([1, 2, 3, 4, 5])
ortalama = np.mean(a)
print("Ortalama:", ortalama)  # 3.0

np.median(a) #ortadaki değeri verir

# 2D dizi ile
b = np.array([[1, 2, 3],
              [4, 5, 6]])

print("Genel ortalama:", np.mean(b))           # 3.5
print("Satır ortalamaları:", np.mean(b, axis=1))  # [2.0, 5.0]
print("Sütun ortalamaları:", np.mean(b, axis=0))  # [2.5, 3.5, 4.5]

"""#np.std() – Standart Sapma

Standart sapma, verinin ne kadar dağınık olduğunu gösterir.

Standart sapma hesaplanırken izlenecek adımlar:
1) Verilerin aritmetik ortalaması bulunur
2) Her bir veri ile aritmetik ortalama arasındaki fark bulunur.
3) Bulunan farkların her birinin karesi alınır ve elde edilen sayılar toplanır.
4) Bu toplam, veri sayısının 1 eksiğine bölünür ve bölümün karekökü bulunur.


İpucu: Varsayılan olarak NumPy popülasyon standart sapmasını hesaplar (yani N'e böler). Örneklem standart sapması istiyorsanız ddof=1 parametresi ekleyin:
`np.std(a, ddof=1)`
"""

a = np.array([1, 2, 3, 4, 5])
std = np.std(a)
print("Standart sapma:", std)  # yaklaşık 1.414

# 2D dizi
b = np.array([[1, 2, 3],
              [4, 5, 6]])
print("Genel standart sapma:", np.std(b))
print("Satır bazlı standart sapma:", np.std(b, axis=1))
print("Sütun bazlı standart sapma:", np.std(b, axis=0))

# toplama, standart sapma ve ortalama, max - min

import numpy as np

# Deneme Verisi: 5 Öğrencinin 3 Sınavdan Aldığı Notlar (5x3 Matris)
# Satırlar: Öğrenciler, Sütunlar: Sınavlar
notlar = np.array([
    [90, 85, 70],
    [60, 75, 80],
    [95, 90, 92],
    [70, 65, 88],
    [80, 70, 75]
])
print("Not Matrisi (5x3):\n", notlar)

# a) Toplam (Sum): Tüm dizinin toplamı
toplam_not = np.sum(notlar)
print(f"\n1. Toplam Not: {toplam_not}")

# b) Ortalama (Mean): Tüm dizinin ortalaması
ortalama_not = np.mean(notlar)
print(f"2. Genel Ortalama: {ortalama_not:.2f}")

# c) Standart Sapma (Std): Verilerin ortalamadan ne kadar saptığı
std_sapma = np.std(notlar)
print(f"3. Standart Sapma: {std_sapma:.2f}")

# d) Min/Max: En küçük ve en büyük notlar
min_not = np.min(notlar)
max_not = np.max(notlar)
print(f"4. En Düşük Not: {min_not}")
print(f"5. En Yüksek Not: {max_not}")

# 1. axis=0: Sınav Ortalamaları (Sütunlar boyunca işlem yap)
sinav_ortalamalari = notlar.mean(axis=0)
print(f"\nSınav Ortalamaları (Axis=0):\n{sinav_ortalamalari.round(2)}")
# Çıktı: [79.00 77.00 81.00] (Her bir sınavın ortalaması)

# 2. axis=1: Öğrenci Ortalamaları (Satırlar boyunca işlem yap)
ogrenci_ortalamalari = notlar.mean(axis=1)
print(f"Öğrenci Ortalamaları (Axis=1):\n{ogrenci_ortalamalari.round(2)}")
# Çıktı: [81.67 71.67 92.33 74.33 75.00] (Her bir öğrencinin ortalaması)

# Argmin / Argmax: En küçük/büyük değerin KENDİSİNİN değil, İNDEKSİNİ döndürür.

# Genel: Dizideki en büyük notun düzleştirilmiş indeksi
en_yuksek_indeks = notlar.argmax()
print(f"\nEn Yüksek Notun Genel İndeksi: {en_yuksek_indeks}") # 7 (dizide 95'in konumu)

# Axis=1: Her öğrencideki en yüksek notun sınav indeksini bulma
en_yuksek_sinav_indeksi = notlar.argmax(axis=1)
print(f"Her Öğrenci İçin En Yüksek Sınav İndeksi (Axis=1): {en_yuksek_sinav_indeksi}")
# Çıktı: [0 2 0 2 0] -> 1. öğrenci 0. sınavda, 2. öğrenci 2. sınavda en yüksek almış.

# Kümülatif İşlemler (cumsum): Birikimli Toplam
# Gerçek Hayat Örneği: Günlük Satışların Kümülatif Toplamı
gunluk_satislar = np.array([100, 150, 80, 200, 120])
kumuletif_satis = gunluk_satislar.cumsum()
print(f"\nKümülatif Satışlar: {kumuletif_satis}")
# Çıktı: [100 250 330 530 650]

#kümülatif çarpım birikimli çarpım
growth = np.array([1.10, 1.20, 1.05])
np.cumprod(growth)  # [1.10, 1.32, 1.386]

"""Diğer istatistiki işlemler

✔ diff() → ardışık farklar
✔ sort() ve argsort() → sıralama ve indeks sıralama
✔ unique() → benzersiz değerler
✔ where() → koşullu indeksleme
✔ percentile() → % değer analizi (istatistikte önemli)
"""

"""
np.diff() → Ardışık Farklar

Bir dizideki ardışık elemanlar arasındaki farkları döndürür.
"""
import numpy as np

a = np.array([10, 15, 20, 18, 30])
print(np.diff(a))

"""#sort() ve argsort() → Sıralama & İndeks Sırası"""

x = np.array([3, 1, 5, 4])
print(np.sort(x))
print(np.argsort(x))

"""#np.unique benzersiz değerler"""

a = np.array([1,2,3,3,2,4,5,5])
print(np.unique(a))


#freakans almak için
values, counts = np.unique(a, return_counts=True)
print(values, counts)

"""np.percentile() → Yüzdelik Dilim Analizi

İstatistikte kutucuk grafiği (boxplot) temelidir, ML ve veri analizinde çok önemli
"""

data = np.array([10, 20, 30, 40, 50, 60, 70, 80])

print(np.percentile(data, 50))  # Median
print(np.percentile(data, 25))  # Q1
print(np.percentile(data, 75))  # Q3

"""# all ve any kullanımı"""

dizi = np.random.randint(1,10,(5,5))
dizi

np.all(dizi > 5)
np.all(dizi > 2)

np.any(dizi > 9)
np.any(dizi > 8)

"""#np.where ile koşullu işlemler
değer atama ve filtreleme de kullanılır
"""

#Basit Kullanım: Koşul → Doğruysa X, Yanlışsa Y

a = np.array([1, 2, 3, 4, 5])

# Eleman 3'ten büyükse "yüksek", değilse "düşük" yaz
sonuc = np.where(a > 3, "yüksek", "düşük")
print(sonuc)  # ['düşük' 'düşük' 'düşük' 'yüksek' 'yüksek']

#Sayısal Değerlerle Kullanım
# Eleman 3'ten büyükse 100, değilse -100
b = np.where(a > 3, 100, -100)
print(b)  # [-100 -100 -100  100  100]

#Sadece Koşulu Sağlayan İndeksleri Bulma

# a > 3 koşulunu sağlayan elemanların indekslerini al
indeksler = np.where(a > 3)
print("Koşulu sağlayan indeksler:", indeksler[0])  # [3 4]

# Bu indeksleri kullanarak değerleri alabiliriz
print("Koşulu sağlayan değerler:", a[indeksler])  # [4 5]

"""

Alternatif: a[a > 3] yazarak doğrudan filtreleme yapabilirsiniz.
np.where daha esnektir çünkü üçlü (koşul, doğru, yanlış) kullanım sunar. """

# Gerçek Hayat Örneği: Karlılık Sütunu Oluşturma
# Kar: > 0, Zarar: < 0, Nötr: = 0
gelirler = np.array([1000, 800, 1200, 950])
maliyetler = np.array([850, 900, 1100, 950])

kar_zarar = gelirler - maliyetler
print(f"Kar/Zarar: {kar_zarar}") # [ 150 -100  100    0]

# Koşullu Dönüşüm 1: Pozitifse 1, Negatifse -1, Sıfırsa 0
kar_zarar_durumu = np.where(kar_zarar > 0, 1, # Kar varsa 1
                           np.where(kar_zarar < 0, -1, 0)) # Zarar varsa -1, yoksa 0 (Nötr)
print(f"Kar/Zarar Durumu (1, -1, 0): {kar_zarar_durumu}")

# Gerçek Hayat Örneği 2: Veri Sınırlama (Outlier/Uç Değer Temizliği)
# Notları en az 50 ve en fazla 100 ile sınırlama (50'den düşükse 50 yap)
sinif_notlari = np.array([30, 75, 105, 45, 90])

sinirlanmis_notlar = np.where(sinif_notlari < 50, 50, # 50'den düşükse 50 yap
                              np.where(sinif_notlari > 100, 100, sinif_notlari)) # 100'den büyükse 100 yap, değilse kendi değerini koru
print(f"\nSınırlı Notlar: {sinirlanmis_notlar}")

#where karışık problemler

print("\n" + "="*60)
print("=== 3. np.where() ve KOŞULLU İŞLEMLER ===\n")

# Örnek: Öğrenci notları üzerinde koşullu işlemler
ogrenci_notlari = np.array([45, 67, 82, 91, 58, 73, 39, 88, 76, 62, 55, 95])
print("Öğrenci notları:", ogrenci_notlari)

# 3.1 TEMEL np.where() KULLANIMI
print("\n3.1 TEMEL np.where() KULLANIMI:")

# Koşul: Not 60 ve üzeri ise "Geçti", değilse "Kaldı"
durumlar = np.where(ogrenci_notlari >= 60, "Geçti", "Kaldı")
print("Durumlar:", durumlar)

# 3.2 İÇ İÇE np.where() - ÇOKLU KOŞULLAR
print("\n3.2 İÇ İÇE np.where() - HARF NOTLARI:")

harf_notlari = np.where(ogrenci_notlari >= 90, 'A',
               np.where(ogrenci_notlari >= 80, 'B',
               np.where(ogrenci_notlari >= 70, 'C',
               np.where(ogrenci_notlari >= 60, 'D', 'F'))))

print("Harf notları:", harf_notlari)

# 3.3 KOŞULU SAĞLAYAN İNDEKSLERİ BULMA
print("\n3.3 KOŞULU SAĞLAYAN İNDEKSLER:")

gecen_ogrenci_indeks = np.where(ogrenci_notlari >= 60)[0]
kalan_ogrenci_indeks = np.where(ogrenci_notlari < 60)[0]

print(f"Geçen öğrenci indeksleri: {gecen_ogrenci_indeks}")
print(f"Geçen öğrenci notları: {ogrenci_notlari[gecen_ogrenci_indeks]}")
print(f"Kalan öğrenci sayısı: {len(kalan_ogrenci_indeks)}")

# 3.4 np.select() - DAHA OKUNABİLİR ÇOKLU KOŞULLAR
print("\n3.4 np.select() İLE ÇOKLU KOŞULLAR:")

kosullar = [
    ogrenci_notlari >= 90,                    # Koşul 1: A
    (ogrenci_notlari >= 80) & (ogrenci_notlari < 90),  # Koşul 2: B
    (ogrenci_notlari >= 70) & (ogrenci_notlari < 80),  # Koşul 3: C
    (ogrenci_notlari >= 60) & (ogrenci_notlari < 70),  # Koşul 4: D
    ogrenci_notlari < 60                      # Koşul 5: F
]

secimler = ['Mükemmel', 'İyi', 'Orta', 'Geçer', 'Başarısız']

derecelendirme = np.select(kosullar, secimler, default='Belirsiz')
print("Derecelendirme:", derecelendirme)

# 3.5 KOŞULLU DEĞER ATAMA ve FİLTRELEME
print("\n3.5 KOŞULLU DEĞER ATAMA:")

# Notları 10 puanlık dilimlere göre kategorize etme
not_dilimleri = np.digitize(ogrenci_notlari, bins=[0, 50, 60, 70, 80, 90, 100])
dilim_etiketleri = ['0-49', '50-59', '60-69', '70-79', '80-89', '90-100']
kategorize_notlar = [dilim_etiketleri[i-1] for i in not_dilimleri]

print("Not dilimleri:", kategorize_notlar)

# 3.6 GERÇEK HAYAT UYGULAMASI: MAAŞ ZAM HESAPLAMA
print("\n3.6 GERÇEK HAYAT UYGULAMASI - MAAŞ ZAM HESAPLAMA:")

calisan_maaslari = np.array([25000, 32000, 18000, 45000, 28000, 38000, 22000])
calisan_performans = np.array([85, 92, 65, 95, 78, 88, 72])  # 0-100 arası

# Performansa göre zam oranları
zam_oranlari = np.where(calisan_performans >= 90, 0.15,        # %15 zam
               np.where(calisan_performans >= 80, 0.10,        # %10 zam
               np.where(calisan_performans >= 70, 0.05, 0.02))) # %5 veya %2 zam

yeni_maaslar = calisan_maaslari * (1 + zam_oranlari)

print("Eski maaşlar:", calisan_maaslari)
print("Performans puanları:", calisan_performans)
print("Zam oranları:", zam_oranlari)
print("Yeni maaşlar:", yeni_maaslar.astype(int))

"""
PERFORMANS KARŞILAŞTIRMASI:
NumPy (Vektörel) vs Python (Döngülü)

NumPy avantajları:
- Daha hızlı (C seviyesinde optimize)
- Daha az bellek kullanımı
- Daha okunabilir kod
- Paralel işlem avantajı
"""

"""#np.nan Not a Number

np.nan (Not a Number), kayıp veya tanımsız sayısal veriyi temsil eder.

Gerçek dünya verilerinde eksik veri (NaN – Not a Number) sık karşılaşılan bir durumdur.
"""

# np.nan bir özel değerdir
print(np.nan)  # nan

# np.nan ile herhangi bir karşılaştırma False döner!
print(np.nan == np.nan)  # False ❗
print(np.nan is np.nan)  # True (ama bu güvenilmez)

# Doğru kontrol: np.isnan()
print(np.isnan(np.nan))  # True

#nan ile istatistik

veri = np.array([1, 2, np.nan, 4, 5])
print("Veri:", veri)

# Normal ortalama → nan döner!
print("Normal ortalama:", np.mean(veri))  # nan

# NaN'leri yok sayarak ortalama → np.nanmean()
print("NaN'leri yok sayarak ortalama:", np.nanmean(veri))  # 3.0

# Benzer şekilde:
print("Toplam (NaN yok sayılır):", np.nansum(veri))      # 12.0
print("Standart sapma (NaN yok sayılır):", np.nanstd(veri))  # ~1.58

#Kural: np.nan içeren dizilerde
#np.nan... fonksiyonlarını kullanın (nanmean, nanstd, nansum vb.)

# Eğer değer 3'ten küçükse nan, değilse kendisi kalsın
veri2 = np.where(veri < 3, np.nan, veri)
print("Yeni veri:", veri2)  # [nan nan nan 4. 5.]

# Ortalamayı alalım (nan'leri yok sayarak)
print("Ortalama:", np.nanmean(veri2))  # 4.5

# Kayıp veri içeren bir dizi oluşturma
veri_nan = np.array([10, 20, np.nan, 40, 50])
print(f"Kayıp Veri İçeren Dizi: {veri_nan}")

# Standart istatistikler NAN ile çalışmaz!
ortalama_normal = np.mean(veri_nan)
print(f"\nNormal Ortalama (np.nan nedeniyle bozulur): {ortalama_normal}")
# Çıktı: nan

# np.isnan(): Hangi elemanların kayıp olduğunu kontrol etme
nan_maskesi = np.isnan(veri_nan)
print(f"np.isnan() Maskesi: {nan_maskesi}")
# Çıktı: [False False  True False False]

# Nan-aware İstatistikler: Kayıp veriyi atlayarak doğru sonucu alma
ortalama_nan_aware = np.nanmean(veri_nan)
print(f"Nan-Aware Ortalama (np.nanmean): {ortalama_nan_aware:.2f}")
# Çıktı: 30.00 ( (10+20+40+50) / 4 )

# Nan-aware Toplam
toplam_nan_aware = np.nansum(veri_nan)
print(f"Nan-Aware Toplam (np.nansum): {toplam_nan_aware}")
# Çıktı: 120.0

#nan karışık örnekler

print("\n" + "="*60)
print("=== 4. NaN DEĞERLERİ ve EKSİK VERİ YÖNETİMİ ===\n")

# 4.1 NaN OLUŞTURMA ve TESPİT ETME
print("4.1 NaN OLUŞTURMA ve TESPİT ETME:")

# Sensör verisi örneği (bazı ölçümler başarısız)
sensor_verisi = np.array([23.5, 24.1, np.nan, 25.8, np.nan, 26.3, 24.9, np.nan, 25.5])
print("Sensör verisi (NaN'lar ile):", sensor_verisi)

# NaN tespit fonksiyonları
nan_maskesi = np.isnan(sensor_verisi)
print("NaN maskesi (True=NaN):", nan_maskesi)
print("Toplam NaN sayısı:", np.sum(nan_maskesi))

# NaN olmayan değerleri seçme
gecerli_veri = sensor_verisi[~nan_maskesi]  # ~ operatörü: DEĞİL
print("Geçerli veri:", gecerli_veri)

# 4.2 NaN DOSTU İSTATİSTİKSEL FONKSİYONLAR
print("\n4.2 NaN DOSTU FONKSİYONLAR:")

print("Normal ortalama (NaN'ler hata verir):", np.mean(sensor_verisi))
print("NaN dostu ortalama:", np.nanmean(sensor_verisi))
print("NaN dostu standart sapma:", np.nanstd(sensor_verisi))
print("NaN dostu toplam:", np.nansum(sensor_verisi))
print("NaN dostu minimum:", np.nanmin(sensor_verisi))

# 4.3 EKSİK VERİ DOLDURMA STRATEJİLERİ
print("\n4.3 EKSİK VERİ DOLDURMA STRATEJİLERİ:")

# Strateji 1: Sabit değerle doldurma
doldurulmus_1 = sensor_verisi.copy()
doldurulmus_1[nan_maskesi] = 0
print("1. Sıfır ile doldurma:", doldurulmus_1)

# Strateji 2: Ortalama ile doldurma
ortalama_deger = np.nanmean(sensor_verisi)
doldurulmus_2 = sensor_verisi.copy()
doldurulmus_2[nan_maskesi] = ortalama_deger
print("2. Ortalama ile doldurma:", doldurulmus_2)

# Strateji 3: Medyan ile doldurma
medyan_deger = np.nanmedian(sensor_verisi)
doldurulmus_3 = sensor_verisi.copy()
doldurulmus_3[nan_maskesi] = medyan_deger
print("3. Medyan ile doldurma:", doldurulmus_3)

# 4.4 DOĞRUSAL İNTERPOLASYON
print("\n4.4 DOĞRUSAL İNTERPOLASYON:")

def linear_interpolate(dizi):
    """NaN değerleri doğrusal interpolasyon ile doldurur"""
    nans = np.isnan(dizi)
    # NaN olmayan indeksleri bul
    x = lambda z: z.nonzero()[0]
    # Interpolasyon uygula
    dizi[nans] = np.interp(x(nans), x(~nans), dizi[~nans])
    return dizi

interpole_veri = linear_interpolate(sensor_verisi.copy())
print("İnterpolasyon ile doldurulmuş:", interpole_veri)

# 4.5 SONSUZ DEĞERLERLE ÇALIŞMA
print("\n4.5 SONSUZ DEĞERLERLE ÇALIŞMA:")

sonsuz_dizi = np.array([1, 2, np.inf, 4, -np.inf, 6, np.nan])
print("Orijinal dizi:", sonsuz_dizi)
print("Sonsuz değerler:", np.isinf(sonsuz_dizi))
print("Sonlu değerler:", np.isfinite(sonsuz_dizi))
print("NaN değerler:", np.isnan(sonsuz_dizi))

# Sonsuz değerleri temizleme
sonlu_veri = sonsuz_dizi[np.isfinite(sonsuz_dizi)]
print("Sonlu değerler:", sonlu_veri)

# 4.6 GERÇEK HAYAT UYGULAMASI: HAVA DURUMU VERİSİ
print("\n4.6 GERÇEK HAYAT UYGULAMASI - HAVA DURUMU VERİSİ:")

# 7 günlük sıcaklık verisi (bazı günler ölçüm yapılamamış)
sicaklik_verisi = np.array([22.5, np.nan, 24.1, 23.8, np.nan, 25.2, 24.7])
print("Ham sıcaklık verisi:", sicaklik_verisi)

# Eksik veri analizi
print("Eksik veri sayısı:", np.sum(np.isnan(sicaklik_verisi)))
print("Eksik veri oranı: %{:.1f}".format(np.mean(np.isnan(sicaklik_verisi)) * 100))

# Çoklu doldurma stratejileri karşılaştırması
strategiler = {
    'Ortalama': np.nanmean(sicaklik_verisi),
    'Medyan': np.nanmedian(sicaklik_verisi),
    'Komşu Ortalama': np.nanmean([22.5, 24.1]),  # Önceki ve sonraki değerler
    'Mevsimsel Ortalama': 23.0  # Tarihsel veri
}

print("\nDoldurma stratejileri karşılaştırması:")
for strateji, deger in strategiler.items():
    tam_veri = sicaklik_verisi.copy()
    tam_veri[np.isnan(sicaklik_verisi)] = deger
    print(f"  {strateji}: {tam_veri}")

"""
EKSİK VERİ STRATEJİ SEÇİMİ:
- Küçük veri setleri: İnterpolasyon veya komşu değerler
- Büyük veri setleri: Ortalama/Medyan doldurma
- Zaman serileri: Önceki değerle doldurma (forward fill)
- Kritik uygulamalar: Çoklu imputation yöntemleri
"""

"""# np.loadtxt() ile dosya işlemleri:"""

#colab üzerinde dosya oluşturma
# Örnek veri dosyası oluşturalım
veri_icerik = """1.0,2.0,3.0
4.0,5.0,6.0
7.0,8.0,9.0"""

# Dosyayı kaydedelim
with open('veri.csv', 'w') as f:
    f.write(veri_icerik)

print("veri.csv dosyası oluşturuldu.")

# Virgülle ayrılmış veriyi okuyalım
veri = np.loadtxt('veri.csv', delimiter=',')
print("Okunan veri:\n", veri)
print("Shape:", veri.shape)  # (3, 3)

# Başlıklı dosya oluşturalım
veri_baslikli = """x,y,z
1.0,2.0,3.0
4.0,5.0,6.0
7.0,8.0,9.0"""

with open('veri_baslikli.csv', 'w') as f:
    f.write(veri_baslikli)

#Eğer dosyanızda sütun isimleri varsa, skiprows kullanın:
# İlk satırı atlayarak oku
veri2 = np.loadtxt('veri_baslikli.csv', delimiter=',', skiprows=1)
print("Başlıksız veri:\n", veri2)

#eksik veri içeren dosya
veri_nan = """1.0,2.0,3.0
4.0,,6.0
7.0,8.0,"""

with open('veri_nan.csv', 'w') as f:
    f.write(veri_nan)

# Boş alanlar NaN olarak okunur (converters gerekli olabilir, ama basit durumlarda otomatik)
try:
    veri3 = np.loadtxt('veri_nan.csv', delimiter=',')
except ValueError as e:
    print("Hata:", e)
    print("np.loadtxt boş hücreleri otomatik NaN olarak okuyamaz.")

# 🛠️ Çözüm: np.genfromtxt() daha esnektir ve missing_values parametresiyle eksik veriyi işleyebilir.
veri3 = np.genfromtxt('veri_nan.csv', delimiter=',', filling_values=np.nan)
print("Eksik veri ile okunan:\n", veri3)
print("Ortalama (NaN yok sayılır):", np.nanmean(veri3))

#Öneri: Basit ve temiz veriler için loadtxt, eksik veri veya karmaşık yapılar için genfromtxt kullanın.

"""Metin tabanlı (CSV, TXT) dosyaları doğrudan NumPy dizisine yüklemek için kullanılır.

Söz Dizimi: np.loadtxt(fname, delimiter=' ', skiprows=0, dtype=float)
"""

# Adım 1: Örnek bir CSV dosyası oluşturalım (Sadece pratik amaçlı)
# Veri: Sıcaklık, Nem, Rüzgar Hızı
# Başlıklar
# 22.5,55.0,15.0
# 23.1,52.5,18.0
# 22.9,53.0,16.5
veri_str = """Sıcaklık,Nem,RüzgarHızı
22.5,55.0,15.0
23.1,52.5,18.0
22.9,53.0,16.5"""

with open("hava_verisi.csv", "w") as f:
    f.write(veri_str)
print("hava_verisi.csv dosyası oluşturuldu.")


# Adım 2: np.loadtxt ile veriyi yükleme
try:
    # Delimiter (ayıraç) = ',', Başlık satırını (1. satır) atla
    hava_verisi_np = np.loadtxt("hava_verisi.csv",
                                delimiter=",",
                                skiprows=1,
                                dtype=np.float64)
    print(f"\n✅ Yüklenen NumPy Dizisi (Shape: {hava_verisi_np.shape}):\n{hava_verisi_np}")
except Exception as e:
    print(f"Hata oluştu: {e}")

# Adım 3: Yüklenen veri üzerinde Axis ile istatistik hesaplama
# Sütun bazında ortalama (Sıcaklık, Nem ve Rüzgar Hızı'nın ortalaması)
ortalama_olcumler = hava_verisi_np.mean(axis=0)
print(f"\nOrtalama Sıcaklık, Nem, Hız: {ortalama_olcumler.round(2)}")

"""# Veriyi Kaydetme: np.savetxt()
NumPy dizisindeki analiz edilmiş veya dönüştürülmüş veriyi diske kaydetmek.

Söz Dizimi: np.savetxt(fname, X, fmt='%.18e', delimiter=' ')
"""

# Yüklenen veriyi (hava_verisi_np) alıp, kaydedelim.
# fmt='%.2f': float değerleri 2 ondalık basamak hassasiyetiyle kaydet
# delimiter=',': Ayraç olarak virgül kullan
np.savetxt("analiz_edilmis_hava.csv",
           hava_verisi_np,
           fmt='%.2f',
           delimiter="," ,
           header="Sicaklik,Nem,RuzgarHizi",
           comments="# ") # Header ekle ve yorum satırı karakterini belirle

print("\n'analiz_edilmis_hava.csv' dosyası kaydedildi (2 ondalık hassasiyetle).")

# Kaydedilen dosyayı basitçe okuyup kontrol edebiliriz
with open("analiz_edilmis_hava.csv", "r") as f:
    print("\nKaydedilen Dosya İçeriği:")
    print(f.read())

"""# Mini Proje
Amaç: Bir veri dosyasından oku, eksik verileri tespit et, ortalama ve standart sapmayı hesapla.
"""

# Adım 1: Veri dosyası oluştur
data = """85,90,,
92,,88,85
,78,82,90"""

with open('sinav_notlari.csv', 'w') as f:
    f.write(data)

# Adım 2: Oku
notlar = np.genfromtxt('sinav_notlari.csv', delimiter=',', filling_values=np.nan)
print("Notlar:\n", notlar)

# Adım 3: Her sütunun (her sınavın) ortalamasını hesapla
ortalama_sinav = np.nanmean(notlar, axis=0)
print("Her sınavın ortalaması:", ortalama_sinav)

# Adım 4: Genel ortalama
genel_ortalama = np.nanmean(notlar)
print("Genel sınıf ortalaması:", genel_ortalama)

#dosya işlemleri karışık örnekler

print("\n" + "="*60)
print("=== 5. DOSYA İŞLEMLERİ - np.loadtxt() ve np.genfromtxt() ===\n")

import os

# 5.1 ÖRNEK CSV DOSYASI OLUŞTURMA
print("5.1 ÖRNEK CSV DOSYASI OLUŞTURMA:")

csv_icerik = """isim,yas,maas,departman,cinsiyet
Ali,25,50000,Mühendislik,E
Ayşe,30,60000,Satış,K
Mehmet,35,75000,Mühendislik,E
Zeynep,28,55000,İK,K
Fatma,32,48000,Satış,K
Can,29,,Mühendislik,E
Deniz,27,52000,İK,K
Emre,31,68000,Satış,E"""

# Dosyayı kaydet
with open('calisanlar.csv', 'w', encoding='utf-8') as f:
    f.write(csv_icerik)

print("CSV dosyası oluşturuldu: calisanlar.csv")

# 5.2 np.loadtxt() - BASİT DOSYALAR İÇİN
print("\n5.2 np.loadtxt() - BASİT DOSYALAR İÇİN:")

try:
    # Sadece sayısal sütunları okumaya çalış
    sayisal_veri = np.loadtxt('calisanlar.csv', delimiter=',', skiprows=1,
                             usecols=(1, 2), encoding='utf-8')
    print("loadtxt() başarılı:\n", sayisal_veri)
except Exception as e:
    print(f"loadtxt() hatası: {e}")
    print("Neden: Eksik veri (NaN) içeren dosyalarda hata verir")

# 5.3 np.genfromtxt() - GELİŞMİŞ OKUMA
print("\n5.3 np.genfromtxt() - GELİŞMİŞ OKUMA:")

# Tüm veriyi oku (eksik verileri handle ederek)
veri = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                     dtype=None, encoding='utf-8',
                     missing_values='', filling_values=0)

print("genfromtxt() ile okunan veri:")
print(veri)
print("Veri tipi:", veri.dtype)
print("Boyut:", veri.shape)

# 5.4 KONTROLLÜ SÜTUN OKUMA
print("\n5.4 KONTROLLÜ SÜTUN OKUMA:")

# Her sütunu ayrı ayrı ve uygun tiplerde oku
isimler = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                       usecols=0, dtype='U10', encoding='utf-8')

yaslar = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                      usecols=1, dtype=int, encoding='utf-8')

maaslar = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                       usecols=2, dtype=float, encoding='utf-8',
                       missing_values='', filling_values=np.nan)  # NaN olarak işaretle

departmanlar = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                           usecols=3, dtype='U15', encoding='utf-8')

cinsiyetler = np.genfromtxt('calisanlar.csv', delimiter=',', skip_header=1,
                          usecols=4, dtype='U1', encoding='utf-8')

print("\nAyrı ayrı okunan sütunlar:")
print("İsimler:", isimler)
print("Yaşlar:", yaslar)
print("Maaşlar:", maaslar)
print("Departmanlar:", departmanlar)
print("Cinsiyetler:", cinsiyetler)

# 5.5 VERİ ANALİZİ
print("\n5.5 OKUNAN VERİ ÜZERİNDE ANALİZ:")

print("Temel istatistikler:")
print(f"  Ortalama yaş: {np.mean(yaslar):.1f}")
print(f"  Ortalama maaş: {np.nanmean(maaslar):.0f} TL")
print(f"  Eksik maaş sayısı: {np.sum(np.isnan(maaslar))}")

print("\nDepartman bazlı analiz:")
for departman in np.unique(departmanlar):
    departman_maskesi = departmanlar == departman
    departman_maaslari = maaslar[departman_maskesi]
    gecerli_maaslar = departman_maaslari[~np.isnan(departman_maaslari)]

    if len(gecerli_maaslar) > 0:
        print(f"  {departman}: {len(gecerli_maaslar)} kişi, Ortalama: {np.mean(gecerli_maaslar):.0f} TL")

# 5.6 VERİYİ DOSYAYA KAYDETME
print("\n5.6 VERİYİ DOSYAYA KAYDETME:")

# İşlenmiş veriyi birleştir
islenmis_veri = np.column_stack((isimler, yaslar, maaslar, departmanlar, cinsiyetler))

# CSV formatında kaydet
np.savetxt('islenmis_calisanlar.csv', islenmis_veri, delimiter=',',
          fmt='%s', header='isim,yas,maas,departman,cinsiyet', comments='')

print("İşlenmiş veri 'islenmis_calisanlar.csv' dosyasına kaydedildi")

# 5.7 FARKLI DOSYA FORMATLARI
print("\n5.7 FARKLI DOSYA FORMATLARI İÇİN PARAMETRELER:")

parametreler = {
    'delimiter': "Sütun ayracı (',', ';', '\\t', ' ')",
    'skiprows': "Atlanacak satır sayısı",
    'usecols': "Okunacak sütun indeksleri",
    'dtype': "Veri tipi (None, int, float, 'U10')",
    'encoding': "Dosya encoding'i ('utf-8', 'latin-1')",
    'missing_values': "Eksik veri işaretçisi",
    'filling_values': "Eksik veri yerine konacak değer"
}

print("Önemli parametreler:")
for param, aciklama in parametreler.items():
    print(f"  {param}: {aciklama}")

# Temizlik: Oluşturulan dosyaları sil
#os.remove('calisanlar.csv')
#os.remove('islenmis_calisanlar.csv')

"""
DOSYA OKUMA STRATEJİLERİ:
- Temiz, sayısal veri: np.loadtxt()
- Karmaşık, eksik veri içeren: np.genfromtxt()
- Büyük dosyalar: Chunk okuma (iterator kullanımı)
- Özel formatlar: Pandas kütüphanesi
"""

"""#kapsamlı örnek"""

"""
Detaylı, açıklamalı NumPy örnekleri — İleri Seviye İstatistiksel Fonksiyonlar

Bu dosya, kullanıcıya adım adım açıklamalar ile birlikte aşağıdaki konuları gösterir:
 - np.unique() ve return_counts kullanımı
 - np.bincount() ile hızlı tamsayı sayımı (sınırlamalar ve offset)
 - np.histogram() ile histogram oluşturma, bins ve edges açıklaması
 - Korelasyon (np.corrcoef) ve kovaryans (np.cov) hesaplama ve yorumlama
 - Kümülatif işlemler: np.cumsum, kümülatif ortalama hesaplama
 - Sıralama ve argsort: artan/azalan sıra, en çok/az satan seçim
 - Finansal analiz örneği: ortalama getiri, volatilite, Sharpe oranı, kumulatif getiri, maksimum drawdown

Her blokta: amaç, önemli parametreler, sınırlar, hata/uyarı notları ve örnek çıktı bulunur.
"""

import numpy as np

# -----------------------------------------------------------------------------
# Genel: ekran başlıkları
# -----------------------------------------------------------------------------
print("\n" + "="*60)
print("=== 6. İLERİ SEVİYE İSTATİSTİKSEL FONKSİYONLAR ===\n")

# -----------------------------------------------------------------------------
# 6.1 np.unique() - BENZERSİZ DEĞERLER ve FREKANSLAR
# -----------------------------------------------------------------------------
# Amaç:
# - Bir kategorik dizide hangi benzersiz kategorilerin bulunduğunu bulmak ve
#   her bir kategorinin kaç kere tekrarlandığını (frekans) hızlı şekilde elde etmek.
# Önemli parametreler:
# - return_counts: True verilirse her benzersiz değerin kaç kere geçtiği döndürülür.
# - return_index / return_inverse: farklı indeks bilgileri almak için kullanılır.
# Notlar:
# - np.unique sonucun sıralı olacağını garanti eder (lexicographic order for strings),
#   bu yüzden frekanslar da bu sıralı benzersiz değer sırasına karşılık gelir.

print("6.1 np.unique() - BENZERSİZ DEĞERLER:")

# Müşteri segment verisi (örnek kategorik veri)
musteri_segmentleri = np.array(['A', 'B', 'A', 'C', 'B', 'A', 'A', 'C', 'B', 'A'])
print("Müşteri segmentleri:", musteri_segmentleri)

# return_counts=True ile benzersiz değerleri ve her birinin frekansını alıyoruz
benzersiz_segmentler, frekanslar = np.unique(musteri_segmentleri, return_counts=True)
print("Benzersiz segmentler:", benzersiz_segmentler)
print("Frekanslar:", frekanslar)

# Frekansları yüzde olarak da gösterme - döngü ile her segmentin oranı
for segment, freq in zip(benzersiz_segmentler, frekanslar):
    oran = freq / len(musteri_segmentleri) * 100
    print(f"  Segment {segment}: {freq} müşteri (%{oran:.1f})")

# Ek bilgi:
# - Eğer veride NaN veya None varsa, np.unique bu değerleri de benzersiz olarak döndürebilir
#   (örneğin numpy.nan string'lerden ayrı bir benzersiz değer olur). Kategorik veriler
#   için pandas kullanmak daha esnek dönüşler sağlar.

# -----------------------------------------------------------------------------
# 6.2 np.bincount() - HIZLI TAMSAYI SAYIMI
# -----------------------------------------------------------------------------
# Amaç:
# - Bütün elemanların non-negative (>=0) tamsayı olduğu dizilerde hızlı frekans sayımı.
# Önemli Notlar:
# - Girdi negatif sayı içerirse hata verir.
# - Dizi değerleri 0..k aralığında ise çıktı uzunluğu k+1 olur.
# - Eğer değerler 1..5 aralığında ise index 0 boş (sıfır) kalır, buna dikkat et.

print("\n6.2 np.bincount() - HIZLI TAMSAYI SAYIMI:")

# Müşteri puanları (1-5 arası) — dikkat: doğrudan bincount'a koyarsak index 0 boş kalacak
musteri_puanlari = np.array([5, 4, 3, 5, 2, 4, 5, 3, 4, 5, 1, 4, 5, 3, 2])
print("Müşteri puanları:", musteri_puanlari)

# Eğer puanlar 1..5 aralığında ise, bincount çıktısı 0..5 index'lerini döndürecek
# ve index 0'ın değeri sıfır olacaktır (çünkü hiç 0 puanı yok).
puan_frekans = np.bincount(musteri_puanlari)
print("Puan frekansları (index=puan):", puan_frekans)

# Daha okunabilir çıktıyı 1'den başlayarak veriyoruz (puan 1..5 aralığı bilinerek)
for puan in range(1, len(puan_frekans)):
    print(f"  {puan} yıldız: {puan_frekans[puan]} müşteri")

# Eğer veri 0-ile başlıyorsa (ör. 0-4 puanlama), bincount doğrudan tam olarak eşleşir.
# Alternatif: eğer puan aralığınız 1..k ise ve indeks 0'ı kullanmak isterseniz,
# "offset" mantığını manuel uygulayabilirsiniz:
# counts = np.bincount(scores - min_score)

# -----------------------------------------------------------------------------
# 6.3 np.histogram() - VERİ DAĞILIMI ANALİZİ
# -----------------------------------------------------------------------------
# Amaç:
# - Sürekli veya geniş aralıklı sayısal verinin hangi aralıklarda (bin'lerde) yoğunlaştığını
#   görmek. np.histogram sayıları sınıflandırıp her bin'in frekansını ve bin sınırlarını döndürür.
# Önemli parametreler:
# - bins: int (eşit genişlikte bins) veya bir dizi (özelleştirilmiş sınırlar)
# - range: histogram için kullanıcı tarafından sınır belirleme
# - density: True ise frekans yerine pdf (yoğunluk) döndürür.

print("\n6.3 np.histogram() - VERİ DAĞILIMI:")

urun_fiyatlari = np.array([45, 120, 85, 220, 150, 95, 180, 75, 250, 130,
                          65, 200, 110, 170, 90])
print("Ürün fiyatları:", urun_fiyatlari)

# bins=5 demek, veri aralığını 5 eşit genişlikli aralığa böler
hist_frekans, hist_sinirlar = np.histogram(urun_fiyatlari, bins=5)
print("Histogram frekansları:", hist_frekans)
print("Histogram sınırları:", hist_sinirlar)

print("\nFiyat dağılımı:")
for i in range(len(hist_frekans)):
    # sinirlar[i] inclusive ve sinirlar[i+1] exclusive (sağ sınır son bin hariç dahil olabilir)
    print(f"  {hist_sinirlar[i]:.0f}-{hist_sinirlar[i+1]:.0f} TL: {hist_frekans[i]} ürün")

# Not:
# - np.histogram sonuçları kapalı-açık aralık mantığında döner (açıklama: left-inclusive,
#   right-exclusive) fakat son binin sağ sınırı dahil olabilir. Bu küçük nüans belirli durumlarda önemlidir.
# - Eğer özel aralıklar isterseniz bins = [0,50,100,150,200,300] gibi bir liste kullanın.

# -----------------------------------------------------------------------------
# 6.4 KORELASYON ve KOVARYANS
# -----------------------------------------------------------------------------
# Amaç:
# - İki sayısal değişken arasındaki doğrusal ilişkiyi ölçmek (korelasyon) ve ortak
#   değişim miktarını hesaplamak (kovaryans).
# Temel fark:
# - Kovaryans: ölçektir (verinin birimleriyle çarpılır), büyük değerler anlamlı olabilir.
# - Korelasyon: normalize edilmiş kovaryans (Pearson), -1 ile +1 arasında ve yorumlanması kolay.
# Fonksiyonlar:
# - np.cov(x, y)[0,1] -> kovaryans (varsayılan ddof=1 -> örnek kovaryans)
# - np.corrcoef(x, y)[0,1] -> Pearson korelasyon katsayısı

print("\n6.4 KORELASYON ve KOVARYANS:")

gelir = np.array([25000, 32000, 28000, 45000, 38000, 29000, 41000])
harcama = np.array([18000, 22000, 20000, 32000, 28000, 21000, 30000])

# np.corrcoef iki değişkenden bir 2x2 matris döndürür: [[1, r],[r,1]]
korelasyon = np.corrcoef(gelir, harcama)[0, 1]
# np.cov döndürdüğü 2x2 matrisin üst-triangular veya [0,1] elementi ortak kovaryanstır
kovaryans = np.cov(gelir, harcama)[0, 1]

print(f"Gelir: {gelir}")
print(f"Harcama: {harcama}")
print(f"Korelasyon katsayısı: {korelasyon:.3f}")
print(f"Kovaryans: {kovaryans:.2f}")

# Korelasyon yorum katmanları — bunlar genel rehberlik için basit eşik değerleridir.
# Gerçekte yorum, bağlama ve veri setine göre değişir (ör. p-değerleri, görselleştirme ile desteklenmelidir).
if korelasyon > 0.7:
    yorum = "Güçlü pozitif ilişki"
elif korelasyon > 0.3:
    yorum = "Orta pozitif ilişki"
elif korelasyon > -0.3:
    yorum = "Zayıf ilişki"
elif korelasyon > -0.7:
    yorum = "Orta negatif ilişki"
else:
    yorum = "Güçlü negatif ilişki"

print(f"Yorum: {yorum}")

# -----------------------------------------------------------------------------
# 6.5 KÜMÜLATİF İŞLEMLER
# -----------------------------------------------------------------------------
# Amaç:
# - Zaman veya sıralı verilerde biriken etkiyi görmek: cumsum, cumprod, accumulate
# - Kümülatif ortalama: her adımda o güne kadar olan ortalamayı verir
# Önemli Parametreler/Dikkatler:
# - dtype: büyük tamsayıların taşmasını önlemek için dtype belirtilebilir
# - np.cumsum, np.cumprod döndürdüğü dizinin dtype'sını dikkat eder (örn. int32 taşma olabilir)

print("\n6.5 KÜMÜLATİF İŞLEMLER:")

aylik_satislar = np.array([12000, 15000, 13000, 18000, 16000, 20000])
print("Aylık satışlar:", aylik_satislar)

kumulatif_toplam = np.cumsum(aylik_satislar)
# Kümülatif ortalama = (toplam so far) / (eleman sayısı so far)
kumulatif_ortalama = kumulatif_toplam / np.arange(1, len(aylik_satislar) + 1)

print("Kümülatif toplam:", kumulatif_toplam)
# astype(int) ile gösterirken kesirleri atıyoruz; isterseniz float olarak bırakın
print("Kümülatif ortalama:", kumulatif_ortalama.astype(int))

# -----------------------------------------------------------------------------
# 6.6 SIRALAMA ve ARGSORT
# -----------------------------------------------------------------------------
# Amaç:
# - argsort ile orijinal dizideki elemanların hangi indekslerde yer alması gerektiğini
#   buluruz (sıralama indeksi)
# - argsort()[::-1] ile azalan sıra elde edilir
# Notlar:
# - numpy.argsort, default olarak quicksort benzeri bir yöntem kullanır; stable sorting istenirse
#   kind='stable' verilebilir (ör. çoklu kıstaslarda önemlidir)

print("\n6.6 SIRALAMA ve ARGSORT:")

urun_satislari = np.array([150, 85, 220, 95, 180, 65, 240, 130])
print("Ürün satışları:", urun_satislari)

# argsort -> küçükten büyüğe indeks sırası verir
artan_sira_indeks = np.argsort(urun_satislari)
# ters çevirme ile büyükten küçüğe indeks sırası elde ediyoruz
azalan_sira_indeks = artan_sira_indeks[::-1]

print("Artan sırada indeksler:", artan_sira_indeks)
print("Azalan sırada indeksler:", azalan_sira_indeks)

# En çok satan 3 ürünü azalan sıra indeks ile alıyoruz
print("En çok satan 3 ürün:", urun_satislari[azalan_sira_indeks[:3]])
print("En az satan 3 ürün:", urun_satislari[artan_sira_indeks[:3]])

# -----------------------------------------------------------------------------
# 6.7 GERÇEK HAYAT UYGULAMASI: FİNANSAL ANALİZ
# -----------------------------------------------------------------------------
# Amaç:
# - Günlük getiri dizisinden temel risk/performans metrikleri hesaplama
# - Ortalama getiri, volatilite (standart sapma), basit Sharpe oranı
# - Kümülatif getiri ve maximum drawdown (en büyük düşüş) hesabı
# Dikkat:
# - Sharpe oranı burada basit: avg_return / std. Gerçek Sharpe hesaplaması genelde
#   risk-free rate düşüldükten sonra yıllıklaştırma içerir.
# - getiri_oranlari yüzde (%) olarak verilmiştir; cumprod için 1 + r/100 uygulanır.

print("\n6.7 GERÇEK HAYAT UYGULAMASI - FİNANSAL ANALİZ:")

getiri_oranlari = np.array([2.5, -1.2, 3.8, 0.5, -2.1, 4.2, 1.8, -0.9, 3.1, 2.8])
print("Günlük getiri oranları (%):", getiri_oranlari)

ortalama_getiri = np.mean(getiri_oranlari)
getiri_volatilitesi = np.std(getiri_oranlari)
# Basit Sharpe: getiri ortalaması / volatilite (aynı birimde oldukları için doğrudan bölüyoruz)
sharpe_orani = ortalama_getiri / getiri_volatilitesi

print(f"Ortalama getiri: %{ortalama_getiri:.2f}")
print(f"Volatilite: %{getiri_volatilitesi:.2f}")
print(f"Sharpe Oranı: {sharpe_orani:.2f}")

# Kümülatif getiri: her gün için (1 + r/100) çarpımları
kumulatif_getiri = np.cumprod(1 + getiri_oranlari/100)
print("Kümülatif getiri (zaman içi):", kumulatif_getiri)

# Maksimum drawdown: geçmişteki maksimuma göre yüzdelik düşüş
maksimum_getiri = np.maximum.accumulate(kumulatif_getiri)
# drawdown genelde negatif değerler olur; en büyük (en olumsuz) drawdown en küçük sayıdır
drawdown = (kumulatif_getiri - maksimum_getiri) / maksimum_getiri * 100
maksimum_drawdown = np.min(drawdown)
print(f"Maksimum Drawdown: %{maksimum_drawdown:.2f}")

# -----------------------------------------------------------------------------
# Kısa özet ve kullanım önerileri
# -----------------------------------------------------------------------------
print("\nİLERİ İSTATİSTİKSEL ANALİZ UYGULAMALARI ÖZETİ:")
print("- Müşteri segmentasyonu: np.unique() + frekans analizi")
print("- Risk yönetimi: Volatilite ve drawdown analizi")
print("- Performans ölçümü: Sharpe oranı ve korelasyon analizi")
print("- Trend analizi: Kümülatif işlemler ve sıralama")

print("\n" + "="*60)
print("NUMPY OTURUM 3 TAMAMLANDI!")
print("Öğrenilen ana başlıklar:")
print("1. İstatistiksel fonksiyonlar ve merkezi eğilim ölçütleri")
print("2. Yüzdelik dilimler ve quantile analizi")
print("3. np.where() ve koşullu işlemler")
print("4. NaN değer yönetimi ve eksik veri stratejileri")
print("5. Dosya işlemleri (loadtxt, genfromtxt, savetxt)")
print("6. İleri seviye istatistiksel fonksiyonlar")

"""#ufunc

ufunc, NumPy'da eleman bazlı (element-wise) işlemler yapan yüksek performanslı fonksiyonlardır.

ufuncs, "Evrensel Fonksiyonlar" anlamına gelir ve nesne üzerinde işlem yapan NumPy fonksiyonlarıdır

**Neden ufuncs kullanmalıyız?**
ufuncs, elemanlar üzerinde yineleme yapmaktan çok daha hızlı olan NumPy'de vektörleştirmeyi uygulamak için kullanılır .

Ayrıca hesaplama için çok faydalı olan azaltma, biriktirme vb. gibi yayın ve ek yöntemler de sağlarlar.

*ufuncs ayrıca şu gibi ek argümanlar da alır:*

* whereİşlemlerin nerede gerçekleşeceğini tanımlayan boolean dizisi veya koşulu.

* dtypeelemanların dönüş tipini tanımlama.

* outdönüş değerinin kopyalanacağı çıktı dizisi.
"""

x = [1, 2, 3, 4]
y = [4, 5, 6, 7]
z = []

for i, j in zip(x, y):
  z.append(i + j)
print(z)

z = np.add(x, y)

print(z)

"""# Kendi ufunc'unuzu Nasıl Oluşturursunuz
Kendi ufunc'ınızı oluşturmak için, Python'daki normal fonksiyonlarda yaptığınız gibi bir fonksiyon tanımlamanız ve ardından bunu metoduyla NumPy ufunc kütüphanenize eklemeniz gerekir frompyfunc().

Yöntem frompyfunc()aşağıdaki argümanları alır:

* function- fonksiyonun adı.
* inputs- giriş argümanlarının (dizilerin) sayısı.
* outputs- çıkış dizilerinin sayısı.
"""

def myadd(x, y):
  return x+y

myadd = np.frompyfunc(myadd, 2, 1)

print(myadd([1, 2, 3, 4], [5, 6, 7, 8]))

"""#aritmetiksel ufuncs"""

arr1 = np.array([10, 11, 12, 13, 14, 15])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.add(arr1, arr2)

print(newarr)

newarr = np.subtract(arr1, arr2)

print(newarr)

"""#yuvarlama

Ondalık basamakları kaldırın ve sıfıra en yakın olan ondalık sayıyı döndürün. trunc()ve fix()fonksiyonlarını kullanın.
"""

arr = np.trunc([-3.1666, 3.6667])

print(arr)

arr = np.fix([-3.1666, 3.6667])

print(arr)

"""Fonksiyon around(), eğer >=5 ise önceki rakamı veya ondalık basamağı 1 artırır, aksi takdirde hiçbir şey yapmaz.

Örn. 1 ondalık basamağa yuvarlarsak, 3.16666 = 3.2 olur.


"""

arr = np.around(3.1666, 2)

print(arr)

print("\n" + "="*60)
print("=== 2. MATEMATİKSEL UFUNC'LER ===\n")

# 2.1 TEMEL ARİTMETİK UFUNC'LER
print("2.1 TEMEL ARİTMETİK UFUNC'LER:")

x = np.array([1, 2, 3, 4, 5])
y = np.array([10, 20, 30, 40, 50])

print("x:", x)
print("y:", y)

print("\nTemel Aritmetik İşlemler:")
print("Toplama (add):", np.add(x, y))
print("Çıkarma (subtract):", np.subtract(y, x))
print("Çarpma (multiply):", np.multiply(x, y))
print("Bölme (divide):", np.divide(y, x))
print("Üs alma (power):", np.power(x, 2))
print("Karekök (sqrt):", np.sqrt(x))

# 2.2 MOD ve BÖLME İŞLEMLERİ
print("\n2.2 MOD ve BÖLME İŞLEMLERİ:")

print("Bölüm (floor_divide):", np.floor_divide(y, x))
print("Kalan (mod/remainder):", np.mod(y, x))
print("Hem bölüm hem kalan:")

bolum, kalan = np.divmod(y, x)  # Çoklu output
print("  Bölüm:", bolum)
print("  Kalan:", kalan)

# 2.3 MUTLAK DEĞER ve İŞARET FONKSİYONLARI
print("\n2.3 MUTLAK DEĞER ve İŞARET FONKSİYONLARI:")

karisik_sayilar = np.array([-5, 3.7, -2.1, 0, 8.9, -0.5])
print("Sayılar:", karisik_sayilar)
print("Mutlak değer (absolute):", np.absolute(karisik_sayilar))
print("İşaret (sign):", np.sign(karisik_sayilar))
print("Pozitif mi? (positive):", np.positive(karisik_sayilar))
print("Negatif mi? (negative):", np.negative(karisik_sayilar))

# 2.4 YUVARLAMA FONKSİYONLARI
print("\n2.4 YUVARLAMA FONKSİYONLARI:")

ondalikli_sayilar = np.array([3.14159, 2.71828, 1.41421, 5.6789, 9.8765])
print("Ondalıklı sayılar:", ondalikli_sayilar)

print("Yuvarla (round):", np.round(ondalikli_sayilar, 2))  # 2 basamak
print("Aşağı yuvarla (floor):", np.floor(ondalikli_sayilar))
print("Yukarı yuvarla (ceil):", np.ceil(ondalikli_sayilar))
print("Kesirli kısım (frac):", ondalikli_sayilar - np.floor(ondalikli_sayilar))

# 2.5 LOGARİTMİK FONKSİYONLAR
print("\n2.5 LOGARİTMİK FONKSİYONLAR:")

pozitif_sayilar = np.array([1, 10, 100, 1000, 10000])
print("Pozitif sayılar:", pozitif_sayilar)

print("Doğal logaritma (log):", np.log(pozitif_sayilar))
print("10 tabanlı log (log10):", np.log10(pozitif_sayilar))
print("2 tabanlı log (log2):", np.log2(pozitif_sayilar))
print("Exponential (exp):", np.exp([0, 1, 2, 3]))  # e^0, e^1, e^2, e^3

# 2.6 GERÇEK HAYAT UYGULAMASI: FİNANSAL HESAPLAMALAR
print("\n2.6 GERÇEK HAYAT UYGULAMASI - FİNANSAL HESAPLAMALAR:")

# Basit faiz hesaplama
anapara = np.array([1000, 5000, 10000, 20000])
faiz_orani = 0.08  # %8 yıllık faiz
yil = np.array([1, 3, 5, 10])

gelecek_deger = anapara * np.power(1 + faiz_orani, yil)
print("Anapara:", anapara)
print("Yıl:", yil)
print("Gelecek değer:", gelecek_deger.astype(int))

# Bileşik faiz getirisi
baslangic = 10000
bitis = np.array([11000, 12500, 15000, 18000])
yil_sayisi = 5

getiri_orani = np.power(bitis / baslangic, 1/yil_sayisi) - 1
print(f"\nBaşlangıç: {baslangic} TL")
print("Bitiş değerleri:", bitis)
print("Yıllık getiri oranları: %", (getiri_orani * 100).round(2))