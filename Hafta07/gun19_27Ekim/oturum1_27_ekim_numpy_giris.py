# -*- coding: utf-8 -*-
"""oturum1_27_ekim_numpy_giris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sz9ieAMzfv4YEjYCkuGvX1Gn2F58NwTg

# 1. NumPy Nedir? Neden Kullanırız?


* NumPy (Numerical Python), bilimsel hesaplamalar için Python'un temel kütüphanesidir.

* ndarray (N-dimensional array) adı verilen çok boyutlu, homojen (aynı türden veriler içeren) ve yüksek performanslı dizi yapıları sunar.

* Neden Liste Yerine NumPy?

1. Hız: NumPy, C dilinde yazılmıştır ve elemanlara daha hızlı erişir. Döngü kullanmadan toplu işlemler yapabilir (vectorization).

2. Fonksiyonlar: Lineer cebir, istatistik, Fourier dönüşümü gibi bilimsel işlemler için hazır fonksiyonlar içerir.

2. Broadcasting: Farklı boyutlardaki dizilerle zahmetsizce işlem yapma yeteneği.
"""

# Eğer yüklü değilse komut satırından yükleyin:
# pip install numpy

# Her zaman bu şekilde import edilir (np takma adı gelenekseldir).
import numpy as np

"""# NumPy'a Giriş: Neden İhtiyaç Duyarız?


| Özellik                              | Python Listesi                                      | NumPy Dizisi (ndarray)                                      |
|--------------------------------------|-----------------------------------------------------|-------------------------------------------------------------|
| Veri Tipi                            | Karma olabilir (int, string, float aynı anda).      | Sadece tek tip veri barındırır (hepsi int, hepsi float, vb.). |
| Hız                                  | Yavaş. Her eleman ayrı bir yerde saklanır; işlem yapmak için döngü gerekir. | Çok hızlı. Tüm elemanlar yan yana, tek bir bellek bloğunda saklanır. |
| İşlem Tipi                           | Element-wise (eleman bazlı) matematiksel işlemler yapamaz. | Vektörel işlemler yapabilir (tek komutla binlerce işlemi aynı anda yapar). |

![numpvslist.png](data:image/png;base64,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//7MM88EXbd27VoXTAX+rkeNGpWwbUVkOrn417/+NaNUqVLZBqoXXXRRxiuvvOLrv9Wffvop49lnn81o1KhRtvdVPwv9TDJPvAJAusin/xJdNQsAqWrixInWv3//oInvxYoVc8v7zj///IRuG5KLlvkOHjzYpk2bFvR4yexbqcm66uFbtGhRSzZaLl6zZs2gFgDXXHMNS1h95Ntvv3XLTDN7fQYuQX3ttdfClqUjvh555BHXbzN036B+t08//XRWawakhltuucUNA8ykaelaOh461Ajxp56o+nvU81ukXqKiv0f1XO/bt6/rPepXe/bssccee8wmTZoUsU9sYGsgvUbp1KkTrWAApCWCVQCIsaeeesq6dOkSFq6+/PLL1rx584RuG5KPhlipt+WGDRvCrqtcubILXiMNv0q0OXPmuKnHgRYvXmxNmzZN2DYhZxTYqKed3gZSr8+33norrK80EkP9GBVchPZtVOit8FshOFLnRIf+7vQ2U8+ePW3KlCkJ3a50deTIEdcXXcMlV61aFfV2Cr579erlAlU/h+AavqXwWK9fDx48GPE2Gsh51VVXuX6xGqYFAOmMYBUAEhSuqqJh7ty5hKsIo+DkjjvucAc2x44dC7te4YoGOuRkCEQ8aXDR6tWrgwKfRYsWJXSbkD1VqKpSNTDAEYU6ClUVriJ5vP/++64aXBXugfh9pR6FqArpAqfIa6iZhgEhPnbt2uUqh49XsamqVAWM7dq18231eObwLYXHCxcujHq7IkWKWOfOne3222+3qlWrxnUbASBZERn1W1MAACAASURBVKwCQJwQriI3oVfXrl1tzZo1YdcpVJ0+fbpde+21liy0NLJ169ZBl7333nt28cUXJ2ybEJ2mTLdt2zasIokKyOS2du1aa9GihW3bti3ociqMU4uWmderV88+//zzrMsUqi5btiyh25UOVLH5wAMPuCrV0ArxwIrNli1bukC1WbNm5lf79u2zJ554wiZMmGAbN26MejutmFElbvfu3a1kyZJx3UYASHYEqwAQR4SryM0SxJEjR7qDPL0fSsGqqmnKly9vyeDCCy907QwyqRWAWgIguTz++ON28803h/UIpGenPyhUVbiqkDUQPXFTi4LyK664Iuiy2bNnW/v27RO2TalKr8t0skkrRbKr2CxRooQ74dmnTx+rXr26+ZV6oo8fP949Fyhc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fvSjsj8YaDZo0KDidea/tzmuVpNaXbm/ruXXPnLkyJrcLBAAWhNWAWgYeXOTvfbaqySu5tUys2bNqonoV83qZbZgXrWaw8c777yz4li+dD6/vlqVw9SUKVOK35+VX1ezvGo1R/FanblZ7/JMymuuuSZ95zvfWeWu99VwGfyayD+QyVcR5Mv9VzUnNttjjz2Kry1507lq/tpSa7OmO0r+Qee999674v1tttmm2CzQv8MA1BphFYCGIq6uffW4G3Y+5xx3muXVqs8991zNrlptlmeujhs3rlhJ11qet5pf91e/+tXUo0ePipwfpZE/x9T8d2vlDX9ayys1jz766CKoVsNl8FGLFi1KV155Zbr00kuLv2dtyV+f85/fPCe2lkZY5BWreeVq6793+etJHguQxwM0mjwKYNiwYS2ubrjgggvSGWecUdHzAoAoYRWAhoyro0aNSr/85S9bHBdX4/L8wDxHMM8TXFn+HOZL//MIgFodHdGvX78WqzvzJfN5Xmmte++999Ill1ySzjrrrLRkyZKS2/v27Vv83n384x+vyPmR0v33319c7n/nnXcWl/+v6jL4E088sYiq1XYZfHvkERv5dV577bUls0hX1qdPn3TCCScUYw169+6dalG9fq1cE5///OeLjdea5T/DeWXv5ptvXtHzAoAIYRWAhvQ///M/xeWZ5eLqrbfemnr27Fmxc6sV9b4KK6+c+sY3vrHi/W7duqX58+cXM1frQV4ZmDc0euCBB0puy6uN8yrk/PprfZVuLW3qk2f75pXSK2/sU07+OpVXp+a/f9V8GXw5+VuPu+66q3ids2fPXuV9P/rRjxarqD/96U/XxQzgelzdv6b/hgwcOLDFauwcz/NGZQBQK4RVABpWW3F11113LWa/iauNPTfwjTfeKFZv5v/W6zf9+X8Dc+Q59dRTW7zOZltuuWWxI3ueY0lld73v3r17EcLzZfCDBw9OtSbHs6uvvjp997vfXeWc2M6dOxd/3vIPNup15m+9zKNeG/KK5fxneuXf/4ceeqiI6gBQC4RVABqauLr2drrOEWTGjBl1tdN16wCSv+nPG6zU4hzLVVm4cGGxq/p9991X9vYcuvIMzFq9DLuWd73PcX/SpEnp2GOPTZtsskmq1zmxvXr1Kl7jF77whbT11lunepc/H3n16sozRrM8EiCPBmiUkTT59edZqyuv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KgAAAABAkLAKAAAAABAkrAIAAAAABAmrAAAAAABBXdIa+uMf/5huvfXWsrf17ds3HXrooaHnu+eee9JvfvObkuMTJkxIm2666fs+TwAAAACAqgmrTz/9dDrttNPK3ta5c+c0cODANHz48HY/34033pimTZtWcnzUqFHCKgAAAABQ/6MAli1blo477rjivwAAAAAA9WKdz1h97LHH0iWXXLKuPwwAAAAAQH1tXvVv//Zv6cUXX+yIDwUAAAAAUB9hdfHixenEE0/siA8FAAAAAFAfYTWbMWNGmjVrVkd9OAAAAACAdaZL6kBf+MIX0l577ZV69OiR6t1vfvObNH/+/PTqq6+mDTbYIA0cODANHz48denS9qd86dKl6YknnkgvvPBC+stf/pI22WSTtP3226chQ4as9fPL5/bMM8+kl156qTinbbbZJu20004N8XsDAAAAADWzYjVbsGBBOuecc9b68+62226pW7duLX717NlztY/7xS9+UfK4/Ou8885r8zH/8A//UHL/f/3Xf11x+7Rp04oYusMOO6SDDz44HXPMMWncuHHpox/9aPHYCy64IDU1NbV4zjfffDOdeeaZaauttkof/vCH05gxY4rHffrTn07/+I//mPr165euuuqq1b6eJ598suzr+dKXvrTiPrfccktxLv3790/7779/Ovroo9NnP/vZtOeee6bevXunI444Is2bN6/Nj5FXHZf7GJ/85CdTxNChQ0ueY7PNNktLliwJPQ8AAAAA1H1YzS6++OL0+OOPr9Xn/Otf/1ry65133lnt4957772yj3333XfbfEx+3rbun1fkfu5zn0u///3vyz42r0I966yz0pFHHlmsTs3y6tSdd945ff3rX0+vvPJK2cc999xz6dhjjy1+vd/Xk2+bOHFi+pd/+Zf0yCOPtPnabrjhhjRs2LAiEJdzwAEHpI033rjkY9x9993F6tz2eOyxx9JTTz1V8hyjRo2yYhYAAACAxg6reRXn2LFjS44vW7YsHX/88UXoqyff+c530qWXXtqu++Z4efnllxfBc/To0cUl+e2RV61ee+217+v8zj333DR16tR23TcH1ryS9Yc//GHJbV27di1WuLaWQ/FNN93Urucv97xZ/pgAAAAA0NBhtXv37unb3/522mijjUpuyysmL7vsslQvfvSjH6Uvf/nLocecf/756aSTTkpz5swJPe4//uM/gme3PMj++7//e+gxeVxBDuB5fENreUxBOdOnT2/X85YLsHk0QR5HAAAAAACp0Tev2nLLLYuglwNia/mS+EMOOaS4T63LM1Kb5U2gDjzwwGKe6vPPP5/uvPPO9PLLL5c8Jl82n1etNvvQhz6U9t1339SrV69iY6kZM2a0eN5mecxAvow+z15tr3yZfbO8IdbIkSOLzbTeeuut4rL8Bx54oOwK4sWLF6evfvWrJfNd87nusssu6Ve/+lWL4w8//HD6wx/+kAYNGrTKubZ5/EFreYRCp06d2v2aAAAAAKBuw2o2adKkYl5nDngry9EwB9e82rNenHzyyenCCy9M66+//opjixYtSvvtt1969NFH23zcRRddlE455ZQWYTEH6V133bWIs63lz2UkrDY79NBD0/e///0irrZ+vk996lNlP1ZehTplypRirmrrVautw2rz/SdPnhwaA5Bf9/jx44OvBgAAAADqePOq9dZbL11xxRXFf1v78Y9/nO66665UD/bZZ59i9MHKUTXLEfP0009v83ETJkxIp556aslqza222iqdcMIJZR+zcOHC8Pnly+xz1GwdVbOddtqp2Hwqz08tN281r7pt7TOf+UzZjaZWNQ4gz2HNv+etjRgxIvXt27edrwQAAAAAGiCsNoe7tiJhXtGaL0mvdauasfrP//zPbd6Wo2r0ceVGBKzON7/5zdS5c+c2b88rYMeNG1f2tgcffLDk2IYbblisgG1t3rx5xQzdcu677770l7/8peS4TasAAAAAqDUdElazr33ta6lPnz4lx/M80fPOOy/Vsrwad4899mjz9p49e5Y9nuewDhkyJPy4ZcuWhc4vbwy18847r/Z+eRxAOXmmaznRTazKjQHIm5vlWbsAAAAAUEs6LKzmgPatb32r7G3/+Z//mebOnZtqVd6Aa4MNNgg/btttt00dtWK4PYYNG1b2+IIFC8oe33333dPgwYNLjt94443FZf8re/vtt9Ptt99edqRA9+7d23V+AAAAANBwYTUbO3Zs2n///UuO5wh33HHHpaamplSL8mXx7zc2d4RyK4XbWkEbHT1Q7jL+V199Nf3kJz9pcWzWrFlp8eLF7Xo8AAAAAFS7Dg2r2fe+973UrVu3kuN5h/m8yVUtWtXs0lXp0qVL6gjtXRGaV9223kSreQOrtowfP77s67j++utXOwYgr3b92Mc+1q5zAwAAAICGDqsDBgxIZ599dtnbTjnllLK7xq8rf/vb31IjyJfht/d+5VYNlwvhK69yPfDAA0uO33bbbWnJkiXF22+88Ua6++67S+5jtSoAAAAAtarDw2p2+umnp+23375s2GuOcR1h0aJFqREsXLiwXff705/+VPb4xhtvvMrHldvEKv8+5ria3Xrrremvf/1rySrfz372s+06LwAAAACoNhUJq+uvv3667LLL1unHaM+81t/+9repETz22GPtut+TTz5Z9njfvn1X+bi8YrXcfNbp06e3OQZgv/32a/fsVwAAAACoNhUJq9knPvGJtbZisWvXriXH3nvvvVVuupTdddddqRE8++yz6de//vVq73f77beXPT506NBVPi7PWD3qqKNKjs+ePTvNnTs3/fSnPy25zRgAAAAAAGpZxcJqNmXKlNSrV681fp6NNtqo7PGHHnqozcfk6PfII4+kRnHaaacVsbkt8+bNS9ddd12bEXx1JkyYUHJs6dKladiwYWnZsmUtjm+66abpk5/8ZLvOGwAAAACqUUXD6uabb56+/vWvr/Hz9OvXr+zxvEnWq6++WnL8gQceSIcffnhqJPfff38aP358Wrx4ccltTz31VBo5cmTJHNTmaJ1vW53Bgwen3XffvV3nMm7cuPSBD3ygnWcOAAAAANWnS6VP4Nhjj03XXHNN+q//+q/3/Ry77LJL+v73v19yPF/+njfJOuSQQ9LAgQOLzbHyKtZyl6Y3guuvvz7dc889xWrRAQMGFJ+POXPmFKt38+rSco477rjUvXv3dj1/XrX64IMPrvZ+xgAAAAAAUOsqHlY7deqULr/88rTTTju1GfdWZ8yYMWnSpElFKGzt9ddfT1OnTi37uL333rtYydlI/vznP6cf/OAH7bpv3pDqzDPPbPdzjx07Np188sllV8U2y6MBhg8f3u7nBAAAAIBqVNFRACvHthzk3q88p/VLX/pS6DHbbbdduvnmm1MjyNG6f//+ocfkS/VvuOGGYh5qe/Xo0SN95jOfWeV9rFYFAAAAoB5URVjNzjvvvLT11lu/78dPnjy5XbNAsw9+8IPpjjvuaPcl7rUuj0q47777Up8+fdp1/969e6dZs2alESNGhD/WMccc0+ZtXbt2TUcccUT4OQEAAACg2lRNWM2rHb/73e++78evv/76aebMmenCCy9MW2yxRZsfI890zXNFt91229RIBg0alObOnVvMTO3Zs2fZ++TVqV/84heLzaz23Xff9x1xhwwZUva2gw46qNiwDAAAAABSo89YHTVqVGpqalorJzN69Og1eq4uXbqk0047LZ166qnpiSeeSL/73e+KGat5Z/u8SvXDH/5w2nDDDVfcv1u3buGPt2jRovB55Vml7+d17b777mvtc9scTq+44op08cUXF5uFvfjii+mNN94oPj+DBw9OO+64Y7GqdE2NHz8+feUrXyk5bgwAAAAAAPWi4ptXrQvrrbdeEQnzL0rloPx+LvNvr3nz5pWNywceeOA6+5gAAAAA0JCjAKgPzz33XJo+fXrJ8QkTJhQrigEAAACgHgirrDVvvvlmOvzww9Pbb7/d4vgHPvCBNGnSpIqdFwAAAACsbZYQEnbyySenxYsXFzNg8yX+OaTmmbZXXXVVWrhwYcn9jz/++NSnT5+KnCsAAAAArAvCKmEzZ85M8+fPT1dfffVq77vFFlukyZMnd8h5AQAAAEBHMQqAkNdee62Iqu2x/vrrF/NWN91003V+XgAAAADQkYRVQubMmdPuqHr99denvffee52fEwAAAAB0NGGVkMcff3y19/nIRz6S/vu//zsdeuihHXJOAAAAANDRzFitI/37908zZswoOT5gwIC19jFOOumkNHjw4PTQQw+lZ599Ni1atCh17dq1mKU6cODANHr06LTDDjustY8HAAAAANVIWK0jG2+8cRozZsw6/Rj5Ev+DDz64+AUAAAAAjcooAAAAAACAIGEVAAAAACBIWAUAAAAACBJWAQAAAACChFUAAAAAgCBhFQAAAAAgSFgFAAAAAAgSVgEAAAAAgoRVAAAAAIAgYRUAAAAAIKhTU1NTU/RBUMumTp2aJk6cWOnTAAAa0Pjx49O0adMqfRoAQAM68sgj03XXXVfp06grVqwCAAAAAAQJqwAAAAAAQUYBAEAVe/LJJ9OECRPS4sWL01lnnVVcRgwAAEDlCasAUKUWLVqUhg4dml588cUVx2666aY0duzYip4XAAAAwioAVK2RI0eme+65p8Wxbt26pblz56ZBgwZV7LwAAAAwYxUAqtI3v/nNkqiavfPOO2nMmDHFfwEAAKgcK1YBoMo8+uijadddd01Lly5t8z557urUqVM79LwAAAD4O2EVAKpsruqwYcPS888/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)

# Analoji:

* Python Listesi: Farklı boyutlarda ve ağırlıklarda eşyaların olduğu bir alışveriş arabası. Her eşyayı tek tek tartmanız ve işlemeniz gerekir.

* NumPy Dizisi: Aynı tipte (örneğin sadece elma) ve aynı ağırlıkta düzenlenmiş ürünlerin olduğu bir paket. Tüm paketi tek seferde işleyebilirsiniz

# Bellek Kullanımı
"""

import sys

python_list = [1, 2, 3, 4]
print("Python list bellek kullanımı:", sys.getsizeof(python_list), "bytes")

import numpy as np

numpy_array = np.array([1, 2, 3, 4], dtype=np.int32)
print("Numpy array bellek kullanımı:", numpy_array.nbytes, "bytes")

"""# 1.1. Python Listelerinin Sınırları (Hız ve Veri Tipi)
NumPy'ın Süper Gücü: Vektörel İşlem Hızı
Gösterim Örneği: 1 Milyon sayıyı 2 ile çarpmak.
"""

import time
import numpy as np

# 1. Python Listesi ile
py_list = list(range(1000000))

t1 = time.time()
result_py = [x * 2 for x in py_list] # DÖNGÜ (Loop) kullanıyoruz
t2 = time.time()
print(f"Python Listesi Süresi: {t2 - t1:.5f} saniye")
# Çıktı: Python Listesi Süresi: 0.04567 saniye (Yaklaşık)

# 2. NumPy Dizisi ile
np_array = np.array(py_list)

t3 = time.time()
result_np = np_array * 2 # TEK BİR İŞLEM yapıyoruz (Vektörel İşlem)
t4 = time.time()
print(f"NumPy Dizisi Süresi: {t4 - t3:.5f} saniye")
# Çıktı: NumPy Dizisi Süresi: 0.00123 saniye (Yaklaşık)

"""Sonuç: NumPy, Python listelerinden onlarca kat daha hızlıdır. Bu yüzden Veri Bilimi ve Makine Öğreniminde temel kütüphanedir.

# 2. np.array() ve Dizi Oluşturma

* NumPy dünyasındaki ana veri yapısı ndarray (N-Dimensional Array / N-Boyutlu Dizi) olarak adlandırılır.
* Dizi oluşturmanın en temel yolu, bir Python listesini np.array() fonksiyonuna vermektir.
* dtype: Dizideki elemanların veri tipini belirtir (int32, float64, bool_, <U10 string, vb.).
* shape: Dizinin boyut bilgisini veren bir tuple'dır. Örn: (3, 4) -> 3 satır, 4 sütun.
"""

#Numpy dizilerine Array denilmektedir. Bir python listesi oluşturmak için
liste=[1,2,3,4]
liste

import numpy as np
#önce numpy kütüphanesi programa dahil edilmiş as np komutu ile numpy kütüphanesinin kullanımı kolaylaşmıştır
a=np.array([1,2,3,4])
a

# Numpy array’leri oluştururken çift parantez ya da parantez ve köşeli parantez beraber kullanılmalıdır
a=np.array([1,2,3,4])
a=np.array((1,2,3,4))
# her iki kullanım da doğrudur.

#tek parantez kullanılırsa python hata verir.
a=np.array(1,2,3,4)

#array tipini öğrenmek için
type(a)

#boş bir array oluşturmak için
bos_array = np.array([])
bos_array

import numpy as np

#Liste veya Tuple’lardan Array Oluşturmak
#Elimizde bulunan liste ve tuple’lardan da kolaylıkla array oluşturabiliriz. Listelerden array oluşturmak için,
a=[1,2,3,4,5,6]
np.array(a)
#array([1, 2, 3, 4, 5, 6])
#tuple’lardan array oluşturmak için
#b=(10,11,12,13,14)
#np.array(b)
#array([10, 11, 12, 13, 14])

import numpy as np

# A. Tek Boyutlu Dizi (Vektör)
# Bir Python listesini NumPy dizisine çeviriyoruz
a = np.array([1, 2, 3, 4, 5])
print(a)
# Çıktı: [1 2 3 4 5]

# B. İki Boyutlu Dizi (Matris)
# Listelerden oluşan bir listeyi kullanıyoruz
b = np.array([[1, 2, 3],
              [4, 5, 6]])
print(b)
# Çıktı:
# [[1 2 3]
#  [4 5 6]]

# C. Üç Boyutlu Dizi (Tensor)
# Matrislerden oluşan bir liste (Örn: 2 adet 2x3 matris)
c = np.array([[[1, 2, 3], [4, 5, 6]],
              [[7, 8, 9], [10, 11, 12]]])
print(c)

# 1. Python listesinden dizi oluşturma
python_listesi = [1, 2, 3, 4, 5]
numpy_dizisi = np.array(python_listesi)
print("Dizi:", numpy_dizisi)
print("Veri Tipi (dtype):", numpy_dizisi.dtype)
print("Boyut (shape):", numpy_dizisi.shape) # Çıktı: (5,) -> 5 elemanlı 1B vektör
print("---")

# 2. Farklı veri tipleri
karisik_liste = [1, 2.5, 3]
numpy_dizisi2 = np.array(karisik_liste)
print("Karma Liste Dizisi:", numpy_dizisi2)
print("dtype:", numpy_dizisi2.dtype) # Çıktı: float64. NumPy homojen yapıdadır, en kapsamlı tipe dönüştürür.
print("---")

# 3. İki boyutlu dizi (matris) oluşturma
matrix_list = [[1, 2, 3], [4, 5, 6]]
numpy_matrix = np.array(matrix_list)
print("2B Dizi:\n", numpy_matrix)
print("shape:", numpy_matrix.shape) # Çıktı: (2, 3) -> 2 satır, 3 sütun

"""# Özel Dizi Oluşturma Yöntemleri



*   Sıfırlardan, birlerden veya belirli bir değerden oluşan dizi oluşturmak için kullanışlı fonksiyonlar.

| Fonksiyon       | Amaç                                                | Örnek                     | Çıktı                                      |
|-----------------|-----------------------------------------------------|---------------------------|--------------------------------------------|
| `np.zeros()`    | Belirtilen boyutta sıfırlardan oluşan dizi.         | `np.zeros((2, 3))`        | `[[0., 0., 0.], [0., 0., 0.]]`            |
| `np.ones()`     | Belirtilen boyutta birlerden oluşan dizi.           | `np.ones((3, 1))`         | `[[1.], [1.], [1.]]`                      |
| `np.full()`     | Belirtilen boyutta sabit bir sayıdan oluşan dizi.   | `np.full((2, 2), 7)`      | `[[7, 7], [7, 7]]`                        |
| `np.arange()`   | Belirli bir aralıkta sıralı sayılar.                | `np.arange(0, 10, 2)`     | `[0 2 4 6 8]` (Adım 2)                    |
| `np.linspace()` | İki nokta arasında eşit aralıklı sayılar.           | `np.linspace(0, 10, 5)`   | `[0. 2.5 5. 7.5 10.]` (5 adet)            |



*   💡 Not: np.arange() tam sayılarla çalışırken, np.linspace() varsayılan olarak float64 türünde sonuç verir.

"""

# 1. Sıfırlardan oluşan dizi
sifir_dizi = np.zeros(5) # 5 elemanlı, 1B, 0'larla dolu
print("np.zeros(5):", sifir_dizi)

sifir_matrix = np.zeros((2, 3)) # 2x3'lük, 0'larla dolu matrix
print("np.zeros((2, 3)):\n", sifir_matrix)
print("---")

# 2. Birlerden oluşan dizi
bir_dizi = np.ones(4) # 4 elemanlı, 1'lerle dolu
print("np.ones(4):", bir_dizi)
print("---")

# 3. Belirli bir değerle doldurma
bes_dizi = np.full((2, 2), 5) # 2x2'lik, 5'lerle dolu matrix
print("np.full((2, 2), 5):\n", bes_dizi)
print("---")

# 4. Birim Matris (Köşegeni 1, diğerleri 0)
birim_matris = np.eye(3) # 3x3'lük birim matris
print("np.eye(3):\n", birim_matris)
print("---")

# 5. Aralık oluşturma (range benzeri)
np.arange(0, 10, 2) # 0'dan 10'a (10 dahil değil), 2'şer artış
np.arange(15) # 0 -15
aralik_dizi = np.arange(10, 20, 2) # 10'dan 20'ye (20 dahil değil), 2'şer artış
print("np.arange(10, 20, 2):", aralik_dizi)
print("---")

np.arange(0,10)

# 6. Eşit aralıklı noktalar oluşturma
esit_aralik = np.linspace(0, 100, 5) # 0 ile 100 arasında 5 eşit parçaya böler
print("np.linspace(0, 100, 5):", esit_aralik) # Çıktı: [ 0.  25.  50.  75. 100.]

"""# Random ile diziler oluşturmak"""

#rastgele diziler oluşturmak için

#random.rand() metodu:
#0-1	arasında verdiğimiz parametre kadar değer üretir.
np.random.rand(5)

np.random.rand(2,3) # 2x3 lük bir matris oluşturur

#random.normal() metodu:
#Ortalaması 0 varyansı 1 olan 3x3 lük matris oluşturmak için,
np.random.normal(0,10,(3,3))
#aşağıdaki gibi de olabilir
np.random.normal(0,10,size=(3,3))

#ortalaması 10 standart sapması 3 olan bir matris oluşturalım.
np.random.normal(10,3,(3,3))

#random.randint() metodu:
#Bu metod ile girilen değerler arasında istenilen sayı kadar rasgele  integer sayı üretmemizi sağlar. 0-10 arasında rasgele bir sayı oluşturmak istersek
np.random.randint(0,10)


#Eğer random fonksiyonunu kullanırken tek parametre verirsek
np.random.randint(10) # Başlangıç değeri 0 verilmiş gibi değer üretir.


# 3 . Bir parametre girilerek kaç tane sayı oluşturabileceğimizi belirleyebiliriz.
np.random.randint(0,10,8) # 8 elemanlı bir vektör(tek boyutlu dizi) oluşturduk.

# 3X3 lük bir matris oluşturmak istersek
np.random.randint(0,10,(3,3))
"""
array([[4, 4, 4],
       [9, 3, 2],
       [0, 0, 5]])
"""
np.random.randint(0,10,size=(3,3))
"""
array([[6, 9, 4],
       [5, 3, 7],
       [5, 4, 3]])
       """
# random.randn() metodu:
#normal dağılımlı rasgele değerlerden oluşan bir array oluşturmak için kullanılır.
np.random.randn(3,4)

"""# 3 boyutlu dizilerle çalışmak
3 boyutlu array oluşturmak için size fonksiyonuna 3. Bir parametre daha girmek gerekmektedir.
"""

a=np.random.randint(0,10,size=(2,4,3))
a
# Burada  size fonksiyonuna girdiğimiz 1. Parametre array’in kaç boyutlu olduğunu, ikinci parametre satır sayısını ve 3. Parametre ise sütun sayısını belirtmektedir.

a.ndim # 3 boyutlu olduğunu söyler
a.shape # sahip olduğu boyutları ve her boyutun eleman sayısını verir
a.size # eleman sayısını verir toplam
a.dtype # dizi tipini verir

"""# Dizinin Temel Özellikleri (shape, dtype, ndim)

Bir diziyi tanımladıktan sonra, onun yapısını anlamak için bu 3 özelliği kullanırız.

* Boyut => shape
* Şekil => ndim
* Veri Tipi => dtype

# Boyut ve Şekil: shape ve ndim

| Özellik | Açıklama                                                                 |
|---------|--------------------------------------------------------------------------|
| `.shape`| Dizinin boyutlarını gösteren bir tuple (demet). Matrisler için `(satır_sayısı, sütun_sayısı)`. |
| `.ndim` | Dizinin kaç boyutlu olduğunu gösteren sayı.                              |
| `.size` | Dizideki toplam eleman sayısı.                                           |
"""

matris = np.array([[10, 20, 30],
                   [40, 50, 60]])

print(f"1. Dizinin Şekli (Shape): {matris.shape}")
# Çıktı: (2, 3) --> 2 satır, 3 sütun

print(f"2. Dizinin Boyut Sayısı (ndim): {matris.ndim}")
# Çıktı: 2 --> İki boyutlu

print(f"3. Toplam Eleman Sayısı (size): {matris.size}")
# Çıktı: 6 --> 2 * 3 = 6

"""# Veri Tipi: dtype
NumPy dizilerinin en önemli özelliği, tüm elemanların aynı veri tipinde olması zorunluluğudur. Bu, hızın anahtarıdır.

| dtype     | Açıklama                          | Kapladığı Yer |
|-----------|-----------------------------------|----------------|
| `int64`   | Tam sayı (integer) - 64 bit       | Büyük          |
| `int32`   | Tam sayı (integer) - 32 bit       | Orta           |
| `float64` | Ondalıklı sayı (float) - 64 bit   | Büyük          |
| `bool`    | Mantıksal değerler (True/False)   | Küçük          |
"""

# 1. Varsayılan veri tipi (Python'dan gelir, genellikle int32 veya int64)
a = np.array([1, 2, 3])
print(f"a'nın tipi: {a.dtype}")
# Çıktı: a'nın tipi: int64 (Sistemine göre değişebilir)

# 2. Tip belirterek dizi oluşturma
b = np.array([1, 2, 3], dtype=np.float64)
print(f"b'nin tipi: {b.dtype}")
# Çıktı: b'nin tipi: float64

# 3. Ondalıklı bir değer eklenince tip otomatik değişir (Tip Zorlaması)
c = np.array([1, 2, 3.5])
print(f"c'nin tipi: {c.dtype}")
# Çıktı: c'nin tipi: float64 (Tüm elemanlar artık float olmak zorunda)

"""# Temel Aritmetik İşlemler (Vektörel İşlemler)

NumPy'ın en kullanışlı tarafı, matematiksel işlemlerin otomatik olarak tüm diziye eleman bazlı (element-wise) uygulanmasıdır.

* NumPy'da aritmetik işlemler element-wise (eleman bazlı) çalışır.

* Aynı indeksteki elemanlar birbiriyle işleme girer.

* Bu, Python listleriyle yapılan işlemlerden tamamen farklıdır!

#Skaler ile Dizi İşlemleri
Skaler, tek bir sayıdır. Skaleri bir dizi ile işleme sokmak, o sayıyı dizinin her elemanına uygulamak anlamına gelir.
"""

a = np.array([10, 20, 30, 40])
skaler = 5

print(f"Toplama (+): {a + skaler}")
# Çıktı: [15 25 35 45] (Her elemana 5 eklendi)

print(f"Çarpma (*): {a * skaler}")
# Çıktı: [ 50 100 150 200] (Her eleman 5 ile çarpıldı)

print(f"Karekök: {np.sqrt(a)}")
# Çıktı: [3.16.. 4.47.. 5.47.. 6.32..] (Her elemanın karekökü alındı)

"""#İki Dizi Arası İşlemler (Element-wise)
İki dizi arasında işlem yapmanın ön koşulu, şekillerinin (shape) aynı olmasıdır. İşlem, aynı konumdaki (indeksteki) elemanlar arasında yapılır.
"""

dizi1 = np.array([[1, 2], [3, 4]])
dizi2 = np.array([[10, 20], [30, 40]])

# Şekiller aynı: (2, 2) + (2, 2) = (2, 2)
toplam = dizi1 + dizi2
print(f"Toplama (dizi1 + dizi2):\n{toplam}")
# Çıktı:
# [[11 22]
#  [33 44]]

# Dikkat: Matris Çarpımı DEĞİL, eleman bazlı çarpım!
carpim = dizi1 * dizi2
print(f"Çarpım (dizi1 * dizi2):\n{carpim}")
# Çıktı:
# [[ 10  40]
#  [ 90 160]]

"""# Karışık Aritmetiksel işlemler"""

a = np.array([10, 20, 30, 40])
b = np.array([1, 2, 3, 4])

# Toplama
print("a + b =", a + b) # Çıktı: [11 22 33 44]

# Çıkarma
print("a - b =", a - b) # Çıktı: [ 9 18 27 36]

# Çarpma (Element-wise! Matrix çarpımı DEĞİL!)
print("a * b =", a * b) # Çıktı: [ 10  40  90 160]

# Bölme
print("a / b =", a / b) # Çıktı: [10. 10. 10. 10.]

# Üs Alma
print("a ** 2 =", a ** 2) # Çıktı: [ 100  400  900 1600]

# Karşılaştırma: Python Listleri
list_a = [10, 20, 30, 40]
list_b = [1, 2, 3, 4]
# print(list_a * list_b) # HATA VERİR!
print("Liste +:", list_a + list_b) # Çıktı: [10, 20, 30, 40, 1, 2, 3, 4] (Birleştirme yapar)

"""# Broadcasting (Yayınlama)
Broadcasting, NumPy'ın en güçlü ve ilk başta en kafa karıştırıcı özelliğidir. **Farklı şekillere sahip diziler arasında işlem yapmayı sağlayan kural setidir.**
# Broadcasting'in Mantığı
NumPy, iki farklı şekilli diziyi birleştirmeye çalıştığında, daha küçük boyutlu (veya tek boyutlu) diziyi "sanki büyükmüş gibi" otomatik olarak uzatır/yayınlar.



> **Temel Kural:** Daha küçük dizi, daha büyük dizinin şekline uyacak şekilde tekrarlanır (yayınlanır). *İki dizinin boyutları, sağdan sola doğru karşılaştırılır. Boyutlar eşitse veya biri 1 ise uyumludur.*

"""

#Temel Örnek: Skaler Yayınlama

a = np.array([10, 20, 30])  # Şekil: (3,)
b = 5                       # Şekil: Skaler

# NumPy, 5 sayısını otomatik olarak [5, 5, 5] dizisine dönüştürür (yayınlar).
sonuc = a + b
print(sonuc)
# Çıktı: [15 25 35]

# Matris ve Vektör Yayınlama (Satır Bazlı)
#Bu, en sık kullanılan Broadcasting türüdür.

matris = np.array([[1, 2, 3],  # 2x3 Matris
                   [4, 5, 6]])

vektor = np.array([10, 20, 30]) # 1x3 Vektör (Aslında Shape (3,))

# NumPy, vektörü, matrisin tüm satırlarına kopyalar (yayınlar) ve toplar.
# [10, 20, 30]
# [10, 20, 30]
# Sanki böyleymiş gibi işlem yapar.

sonuc = matris + vektor
print(f"Matris Şekli: {matris.shape}")
print(f"Vektör Şekli: {vektor.shape}")
print("-" * 20)
print(f"Broadcasting Sonucu:\n{sonuc}")

# Çıktı:
# [[1 + 10, 2 + 20, 3 + 30],
#  [4 + 10, 5 + 20, 6 + 30]]
# [[11 22 33]
#  [14 25 36]]

"""#Broadcasting Kuralları (Ne Zaman Çalışır?)

İki dizinin yayınlanabilir olması için, şekillerini sağdan sola doğru karşılaştırdığınızda, her boyut için ya:

1. Boyutlar Eşit olmalı (Örn: 3 ve 3)

2. Boyutlardan biri 1 olmalı (Örn: 5 ve 1, veya 1 ve 7)

Aksi takdirde, NumPy hata verir (ValueError: operands could not be broadcast together...).
"""

dizi_A = np.zeros((3, 4)) # 3 satır, 4 sütun
dizi_B = np.zeros((3, 3)) # 3 satır, 3 sütun

# Karşılaştırma (Sağdan Sola):
# 1. Boyut: 4 ve 3. Ne eşitler, ne de biri 1. ❌ Broadcast Yapılamaz.
# dizi_A + dizi_B # Hata verir.

#genel örnek

# Örnek 1: Skaler bir değerle işlem (En basit broadcasting)
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print("Orijinal Matrix:\n", matrix)
print("Matrix + 10:\n", matrix + 10) # 10 sayısı matrix'in her elemanına "yayınlanır"
# Çıktı:
# [[11 12 13]
#  [14 15 16]]
print("---")

# Örnek 2: 1B dizi ile 2B dizi
a = np.array([[1, 2, 3], [4, 5, 6]]) # shape: (2, 3)
b = np.array([10, 20, 30])            # shape: (3,)
# b'nin shape'i (3,) -> (1, 3) olarak genişletilir, sonra (2, 3) olarak tekrarlanır.
print("a + b:\n", a + b)
# Çıktı:
# [[11 22 33]
#  [14 25 36]]
print("---")

# Örnek 3: Yayınlanamayan şekiller (Hata)
c = np.array([10, 20]) # shape: (2,)
# a'nın shape'i (2, 3), c'nin shape'i (2,)
# Sağdan sola: 3 != 2 -> Uyumsuzluk!
try:
    print(a + c) # ValueError: operands could not be broadcast together with shapes (2,3) (2,)
except ValueError as e:
    print("HATA:", e)

"""#numpy Hakkında

1. Hız: NumPy'ın ana avantajı, vektörel işlemler sayesinde Python listelerine göre çok daha hızlı olmasıdır.

2. Veri Tipi: Hızın sırrı, tüm elemanların aynı veri tipinde (dtype) tutulmasıdır.

2. Temel İşlem: Aritmetik işlemler (+, -, *, /) varsayılan olarak eleman bazlı çalışır.

2. Esneklik: Broadcasting, farklı şekillerdeki dizilerin (kurallar dahilinde) işlem yapmasına izin veren sihirli bir özelliktir.

#Sorular:

1. [5, 10, 15, 20, 25] listesinden bir NumPy dizisi oluşturun. shape ve dtype'ını kontrol edin.

2. 4x4'lük bir birim matris oluşturun.

3. 0 ile 1 arasında 6 eşit parçaya bölünmüş bir dizi oluşturun (linspace).

4. a = np.array([2, 4, 6]) ve b = np.array([1, 2, 3]) veriliyor.

  * a + b işleminin sonucu nedir?

  * a * 3 işleminin sonucu nedir?

5. x = np.array([[1], [2], [3]]) (shape: 3x1) ve y = np.array([4, 5, 6]) (shape: 3,) veriliyor.

* x + y işlemini yapmayı dene. Sonucun shape'i ne olur? Tahmin et, sonra dene.
"""

# 1
dizi = np.array([5, 10, 15, 20, 25])
print(dizi.shape, dizi.dtype)

# 2
im = np.eye(4)
print(im)

# 3
dizi = np.linspace(0, 1, 6)
print(dizi)

# 4
a = np.array([2, 4, 6])
b = np.array([1, 2, 3])
print(a + b) # [3 6 9]
print(a * 3) # [ 6 12 18]

# 5
x = np.array([[1], [2], [3]])
y = np.array([4, 5, 6])
sonuc = x + y
print(sonuc)
# Tahmin: x (3,1), y (3,) -> y (1,3) olur, sonra (3,3) olarak yayınlanır.
# Çıktı:
# [[5 6 7]
#  [6 7 8]
#  [7 8 9]]
print("Sonucun shape'i:", sonuc.shape) # (3, 3)

"""# Örnekler

# Temel Dizi Oluşturma: np.array()
Gerçek Hayat Örneği 1: Sensör Verileri
"""

"""
Bir hava durumu istasyonundan gelen sıcaklık,
nem ve rüzgar hızı ölçümlerini NumPy dizisi olarak saklamak.
"""
import numpy as np

# 1. Tek Boyutlu Dizi: Bir cihazdan ardışık gelen tek bir ölçüm serisi (örn. sıcaklıklar)
sicakliklar = np.array([22.5, 23.1, 22.9, 23.5, 24.0])
print(f"Güncel Sıcaklıklar: {sicakliklar}")

# 2. İki Boyutlu Dizi: Farklı sensörlerin aynı anda yaptığı ölçümler (Matris)
# [Sıcaklık, Nem, Rüzgar Hızı]
hava_verisi = np.array([[22.5, 55.0, 15.0],  # 1. Ölçüm
                        [23.1, 52.5, 18.0],  # 2. Ölçüm
                        [22.9, 53.0, 16.5]]) # 3. Ölçüm

print("\nÇoklu Sensör Verisi (Matris):\n", hava_verisi)

"""# Hızlı Dizi Oluşturma Fonksiyonları (Simülasyon ve Başlangıç Değerleri)"""

"""
Gerçek Hayat Örneği 2: Finans ve Simülasyon
"""
#np.zeros()
#Veritabanı Ön Tahsisi: 1000 müşterinin başlangıç bakiyesini sıfır olarak ayarlamak.
bakiyeler = np.zeros(1000)
#print(bakiyeler)

#np.ones()
#A/B Testi: 500 kullanıcının hepsine başlangıçta "Kontrol Grubu (1)" değerini atamak.
test_grubu = np.ones(500)
#print(test_grubu)

#np.full()
#Hata Değeri: Bir anketin boş bırakılan 200 sorusuna sabit bir "Eksik (-999)" değeri atamak.
eksik_veri = np.full((10, 20), -999)
eksik_veri

#np.arange()
#Zaman Serisi: 1'er saat arayla 24 saatlik bir zaman indeksi oluşturmak.
saatler = np.arange(0, 24)
saatler

#np.linspace()
#Grafik Çizimi: Bir fonksiyonun grafiğini çizmek için $x=0$ ile $x=2\pi$ arasında 100 eşit aralıklı nokta oluşturmak.
x_ekseni = np.linspace(0, 2*np.pi, 100)
x_ekseni

"""# Dizinin Temel Özellikleri (shape, dtype, ndim)

# Veri Tipi: dtype (Bellek ve Hassasiyet Optimizasyonu)
"""

"""
Gerçek Hayat Örneği 3: Görüntü İşleme ve Bellek Yönetimi

Görüntüler, piksel değerleri (0-255 arası) içeren matrislerdir.
"""
# Görüntü verisi simülasyonu: 100x100 piksellik bir gri tonlama görüntüsü
resim_data = np.full((100, 100), 150, dtype=np.uint8)
# uint8: Unsigned Integer (İşaretsiz Tamsayı) 8 bit. Sadece 0-255 arası değer alır.

print(f"Resim Verisinin Tipi: {resim_data.dtype}")
# Çıktı: uint8 (Bu veri tipi 1 bayt yer kaplar.)

# Aynı veriyi int64 ile saklarsak:
resim_data_buyuk = np.full((100, 100), 150, dtype=np.int64)
# int64: 8 bayt yer kaplar.

print(resim_data.nbytes)        # 10000
print(resim_data_buyuk.nbytes)  # 80000

# Bellek Karşılaştırması:
# uint8 ile: 100 * 100 * 1 bayt = 10,000 bayt (10 KB)
# int64 ile: 100 * 100 * 8 bayt = 80,000 bayt (80 KB)
# NumPy, doğru dtype kullanarak 8 kat daha az bellek kullanır!

# Tip Zorlaması: Hassasiyet Kaybı
veriler = np.array([1.5, 2.7, 3.2], dtype=np.int32)
print(f"\nTip zorlama sonucu: {veriler}")
# Çıktı: [1 2 3]
# Önemli Not: float'tan int'e geçişte ondalık kısımlar ATILIR, yuvarlanmaz. Veri kaybı yaşanır!

import numpy as np
import matplotlib.pyplot as plt

# 100x100 piksellik gri görüntü (tüm pikseller 150)
resim_data = np.full((100, 100), 150, dtype=np.uint8)

# Görüntüyü göster
plt.figure(figsize=(5, 5))  # Opsiyonel: boyut ayarı
plt.imshow(resim_data, cmap='gray')  # cmap='gray' → gri tonlama
plt.title("100x100 Gri Görüntü (Piksel Değeri: 150)")
plt.axis('off')  # Eksenleri gizle (isteğe bağlı)
plt.show()

"""# Temel Aritmetik İşlemler (Vektörel İşlemler)
# Skaler ile Dizi İşlemleri (Normalizasyon ve Dönüşüm)
"""

"""
Gerçek Hayat Örneği 4: Sıcaklık Dönüşümü (Celsius'tan Fahrenheit'a)
Tüm sıcaklık verisini $F = C \times 1.8 + 32$ formülü ile dönüştürmek için döngüye gerek yok!
"""
celsius_sicakliklar = np.array([10.0, 15.0, 20.0, 25.0]) # Shape (4,)

# Vektörel İşlem: Tek satırda tüm diziye uygulanır
fahrenheit_sicakliklar = celsius_sicakliklar * 1.8 + 32

print(f"Celsius: {celsius_sicakliklar}")
print(f"Fahrenheit: {fahrenheit_sicakliklar}")
# Çıktı: [50. 59. 68. 77.]

# Celsius sıcaklıklarını liste olarak tanımlayalım
celsius_sicakliklar = [10.0, 15.0, 20.0, 25.0]

# Boş bir liste oluşturup döngüyle Fahrenheit değerlerini ekleyelim
fahrenheit_sicakliklar = []

for c in celsius_sicakliklar:
    f = c * 1.8 + 32
    fahrenheit_sicakliklar.append(f)

# Sonuçları yazdır
print(f"Celsius: {celsius_sicakliklar}")
print(f"Fahrenheit: {fahrenheit_sicakliklar}")

"""# İki Dizi Arası İşlemler (Hata Hesaplama)"""

"""

Gerçek Hayat Örneği 5: Model Tahmini ve Gerçek Veri Karşılaştırması

Bir makine öğrenimi modelinin yaptığı tahminler ile gerçek değerler arasındaki hatayı hesaplamak.

"""

gercek_degerler = np.array([10.5, 15.2, 5.8, 8.1])
model_tahminleri = np.array([10.0, 16.0, 6.0, 7.9])

# 1. Hata Hesaplama (Fark Alma)
hata = gercek_degerler - model_tahminleri
print(f"1. Her bir tahminin Hatası: {hata}")
# Çıktı: [ 0.5 -0.8 -0.2  0.2]

# 2. Mutlak Hata (np.abs kullanarak)
mutlak_hata = np.abs(hata)
print(f"2. Mutlak Hata: {mutlak_hata}")
# Çıktı: [0.5 0.8 0.2 0.2]

# 3. Karesel Hata (Hata karesi alınıp toplanır)
karesel_hata = hata ** 2
print(f"3. Karesel Hata: {karesel_hata}")
# Çıktı: [0.25 0.64 0.04 0.04]

# Verileri liste olarak tanımlayalım
gercek_degerler = [10.5, 15.2, 5.8, 8.1]
model_tahminleri = [10.0, 16.0, 6.0, 7.9]

# 1. Hata Hesaplama (Fark Alma)
hata = []
for g, t in zip(gercek_degerler, model_tahminleri):
    fark = g - t
    hata.append(fark)

print(f"1. Her bir tahminin Hatası: {hata}")
# Çıktı: [0.5, -0.8, -0.2, 0.2]


# 2. Mutlak Hata (abs kullanarak)
mutlak_hata = []
for h in hata:
    mutlak_hata.append(abs(h))

print(f"2. Mutlak Hata: {mutlak_hata}")
# Çıktı: [0.5, 0.8, 0.2, 0.2]


# 3. Karesel Hata (Hata karesi)
karesel_hata = []
for h in hata:
    karesel_hata.append(h ** 2)

print(f"3. Karesel Hata: {karesel_hata}")
# Çıktı: [0.25, 0.64, 0.04, 0.04]

"""#Broadcasting (Yayınlama)
# Matris ve Vektör Yayınlama (Veriye Offset Ekleme)
"""

"""
Gerçek Hayat Örneği 6: Eşitlik Testi Öncesi Ortalama Çıkarma

20 kişilik bir öğrenci grubunun 3 farklı sınavdan aldığı puanlar olsun.
Herkesin puanını, o sınavın kendi ortalamasına göre normalize etmek istiyoruz.
"""
# 3 Sınav, 4 Öğrenci (Öğrenci Satır, Sınav Sütun)
puanlar = np.array([[70, 85, 90],
                    [65, 80, 85],
                    [95, 70, 75],
                    [50, 90, 95]]) # Shape: (4, 3)

# Sınav Ortalamalarını Hesaplama (axis=0, yani sütunlar boyunca)
sinav_ortalamalari = puanlar.mean(axis=0)
print(f"Sınav Ortalamaları (Vektör): {sinav_ortalamalari}")
# Çıktı: [70. 81.25 86.25] -> Shape: (3,)

# Broadcasting: (4, 3) matristen (3,) vektörü ÇIKARMA
# NumPy, ortalama vektörünü 4 satır boyunca yayınlar ve her öğrenciden ilgili sınavın ortalamasını çıkarır.
normalize_puanlar = puanlar - sinav_ortalamalari

print("\nNormalize Edilmiş Puanlar (Ortalamadan Fark):\n", normalize_puanlar.round(2))
# Çıktı (Örnek):
# [[ 0.  3.75  3.75]  -> 70-70=0, 85-81.25=3.75, ...
#  [-5. -1.25 -1.25]
#  ... ]

# 3 sınav, 4 öğrenci (öğrenci satır, sınav sütun)
puanlar = [
    [70, 85, 90],
    [65, 80, 85],
    [95, 70, 75],
    [50, 90, 95]
]

# 1️⃣ Sınav ortalamalarını hesaplama (sütun bazında)
sinav_ortalamalari = []

# Her sütun için ortalama hesapla
for j in range(len(puanlar[0])):  # 0,1,2 → 3 sınav
    toplam = 0
    for i in range(len(puanlar)):  # 0–3 → 4 öğrenci
        toplam += puanlar[i][j]
    ortalama = toplam / len(puanlar)
    sinav_ortalamalari.append(ortalama)

print(f"Sınav Ortalamaları (Vektör): {sinav_ortalamalari}")
# Çıktı: [70.0, 81.25, 86.25]

# 2️⃣ Normalizasyon (her öğrencinin puanından o sınavın ortalamasını çıkar)
normalize_puanlar = []

for i in range(len(puanlar)):  # Her öğrenci
    satir_fark = []
    for j in range(len(puanlar[0])):  # Her sınav
        fark = puanlar[i][j] - sinav_ortalamalari[j]
        satir_fark.append(round(fark, 2))
    normalize_puanlar.append(satir_fark)

print("\nNormalize Edilmiş Puanlar (Ortalamadan Fark):")
for satir in normalize_puanlar:
    print(satir)

# Beklenen Çıktı:
# [0.0, 3.75, 3.75]
# [-5.0, -1.25, -1.25]
# [25.0, -11.25, -11.25]
# [-20.0, 8.75, 8.75]