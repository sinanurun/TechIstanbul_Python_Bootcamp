# -*- coding: utf-8 -*-
"""oturum2_29_ekim_numpy_dizi_islemleri.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c9-iU84JGAfobOM9YcxrvQUP6eetPW7o

# np.arange ile listeler Ã¼retmek
numpy.arange([start,] stop[, step], dtype=None)
"""

import numpy as np

a = np.arange(5)
print(a)

b = np.arange(2, 10)
print(b)

c = np.arange(2, 10, 2)
print(c)

d = np.arange(10, 2, -2)
print(d)

#ondalÄ±klÄ± deÄŸerler ile
d = np.arange(0, 1, 0.2)
print(d)

#dtype parametresi ile
# dtype=int / dtype=float / dtype=complex gibi tipler kullanÄ±labilir.
e = np.arange(0, 10, 2, dtype=float)
print(e)

# a) SayÄ±sal aralÄ±klar oluÅŸturmak - Sinyal, grafik veya matematiksel hesaplamalarda sÄ±kÃ§a kullanÄ±lÄ±r.

x = np.arange(0, 2*np.pi, 0.1)
y = np.sin(x)
print(y)

# b) Matris ÅŸekline dÃ¶nÃ¼ÅŸtÃ¼rmek -

a = np.arange(12).reshape(3, 4)
print(a)

"""| Ã–zellik                  | `arange()`                      | `linspace()`              |
| ------------------------ | ------------------------------- | ------------------------- |
| AdÄ±m belirleme           | `step` parametresiyle           | Eleman sayÄ±sÄ± (`num`) ile |
| UÃ§ deÄŸer (stop) dahil mi | **HayÄ±r**                       | **Evet (varsayÄ±lan)**     |
| OndalÄ±k hatasÄ± riski     | Evet (floating-point precision) | HayÄ±r (daha kesin)        |

"""

np.arange(0, 1, 0.2)      # [0. , 0.2, 0.4, 0.6, 0.8]
np.linspace(0, 1, 5)       # [0. , 0.25, 0.5 , 0.75, 1. ]

"""# Ã–rnekler"""

#kare alma
x = np.arange(1, 6)
y = x ** 2
print("x:", x)
print("y:", y)

#grafik Ã§izimi

import matplotlib.pyplot as plt

x = np.arange(0, 2*np.pi, 0.1)
y = np.sin(x)

plt.plot(x, y)
plt.title("SinÃ¼s GrafiÄŸi")
plt.xlabel("x")
plt.ylabel("sin(x)")
plt.show()

#arange dizi oluÅŸturucu Ã¶rnek

import numpy as np

def arange_olusturucu():
    print("ğŸ”¹ NumPy arange() oluÅŸturucuya hoÅŸ geldiniz!\n")

    # KullanÄ±cÄ±dan deÄŸerleri al
    start = input("BaÅŸlangÄ±Ã§ deÄŸerini girin (boÅŸ bÄ±rak = 0): ")
    stop = input("BitiÅŸ deÄŸerini girin (zorunlu): ")
    step = input("AdÄ±m (step) deÄŸerini girin (boÅŸ bÄ±rak = 1): ")
    dtype = input("Veri tipi girin (int, float, complex veya boÅŸ bÄ±rak): ")

    # BoÅŸ bÄ±rakÄ±lan alanlar iÃ§in varsayÄ±lan deÄŸer atama
    start = float(start) if start.strip() != "" else 0
    step = float(step) if step.strip() != "" else 1

    # stop deÄŸeri zorunlu
    if stop.strip() == "":
        print("âš ï¸ 'stop' deÄŸeri zorunludur!")
        return
    stop = float(stop)

    # dtype belirleme
    dtype_map = {"int": int, "float": float, "complex": complex}
    dtype = dtype_map.get(dtype.strip().lower(), None)

    # arange oluÅŸtur
    arr = np.arange(start, stop, step, dtype=dtype)

    # SonuÃ§larÄ± yazdÄ±r
    print("\nâœ… OluÅŸturulan NumPy dizisi:")
    print(arr)
    print(f"\nDizinin veri tipi: {arr.dtype}")
    print(f"Dizinin boyutu (shape): {arr.shape}")
    print(f"Eleman sayÄ±sÄ±: {arr.size}")

# Fonksiyonu Ã§alÄ±ÅŸtÄ±r
arange_olusturucu()

"""# np.random ile diziler oluÅŸturmak

"""

#rastgele diziler oluÅŸturmak iÃ§in

#random.rand() metodu:
#0-1	arasÄ±nda verdiÄŸimiz parametre kadar deÄŸer Ã¼retir.
np.random.rand(5)

np.random.rand(2,3) # 2x3 lÃ¼k bir matris oluÅŸturur

#random.normal() metodu:
#OrtalamasÄ± 0 varyansÄ± 1 olan 3x3 lÃ¼k matris oluÅŸturmak iÃ§in,
np.random.normal(0,10,(3,3))
#aÅŸaÄŸÄ±daki gibi de olabilir
np.random.normal(0,10,size=(3,3))

#ortalamasÄ± 10 standart sapmasÄ± 3 olan bir matris oluÅŸturalÄ±m.
np.random.normal(10,3,(3,3))

#random.randint() metodu:
#Bu metod ile girilen deÄŸerler arasÄ±nda istenilen sayÄ± kadar rasgele  integer sayÄ± Ã¼retmemizi saÄŸlar. 0-10 arasÄ±nda rasgele bir sayÄ± oluÅŸturmak istersek
np.random.randint(0,10)


#EÄŸer random fonksiyonunu kullanÄ±rken tek parametre verirsek
np.random.randint(10) # BaÅŸlangÄ±Ã§ deÄŸeri 0 verilmiÅŸ gibi deÄŸer Ã¼retir.


# 3 . Bir parametre girilerek kaÃ§ tane sayÄ± oluÅŸturabileceÄŸimizi belirleyebiliriz.
np.random.randint(0,10,8) # 8 elemanlÄ± bir vektÃ¶r(tek boyutlu dizi) oluÅŸturduk.

# 3X3 lÃ¼k bir matris oluÅŸturmak istersek
np.random.randint(0,10,(3,3))
"""
array([[4, 4, 4],
       [9, 3, 2],
       [0, 0, 5]])
"""
np.random.randint(0,10,size=(3,3))
"""
array([[6, 9, 4],
       [5, 3, 7],
       [5, 4, 3]])
       """
# random.randn() metodu:
#normal daÄŸÄ±lÄ±mlÄ± rasgele deÄŸerlerden oluÅŸan bir array oluÅŸturmak iÃ§in kullanÄ±lÄ±r.
np.random.randn(3,4)

"""#Temel ve GeliÅŸmiÅŸ Ä°ndeksleme Teknikleri

**Ä°ndeksleme Nedir? Neden Ã–nemli?**

*   Ä°ndeksleme: Dizilerden belirli elemanlarÄ± seÃ§me iÅŸlemidir

*  Ã–nemi: Veri analizinde sadece ilgili verilere odaklanmamÄ±zÄ± saÄŸlar

**TÃ¼rleri:**

* Temel indeksleme (basic indexing)

* GeliÅŸmiÅŸ indeksleme (advanced indexing)

* Boolean indeksleme

* Fancy indeksleme

**Temel Ä°ndeksleme KurallarÄ±:**

* Python'daki liste indekslemeye benzer ama Ã§ok daha gÃ¼Ã§lÃ¼

* `0-tabanlÄ± indeksleme`: Ä°lk eleman indeksi 0'dÄ±r

* *Negatif indeksler*: Sondan saymaya yarar (-1 son eleman)

* *Ã‡ok boyutlu dizilerde*: dizi[satir, sutun] syntax'Ä±
"""

import numpy as np

# 1B Dizi Ä°ndeksleme
dizi_1b = np.array([10, 20, 30, 40, 50])
print("1B Dizi:", dizi_1b)
print("dizi_1b[0]:", dizi_1b[0])           # Ä°lk eleman
print("dizi_1b[-1]:", dizi_1b[-1])         # Son eleman
print("dizi_1b[2:4]:", dizi_1b[2:4])       # 2. ve 3. eleman (4 dahil deÄŸil)
print("dizi_1b[::2]:", dizi_1b[::2])       # Bir atlayarak
print("---")

# 2B Dizi Ä°ndeksleme
dizi_2b = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])
print("2B Dizi:\n", dizi_2b)
print("dizi_2b[0, 1]:", dizi_2b[0, 1])     # 0. satÄ±r, 1. sÃ¼tun -> 2
print("dizi_2b[1, -1]:", dizi_2b[1, -1])   # 1. satÄ±r, son sÃ¼tun -> 8
print("---")

# 3B Dizi Ä°ndeksleme
dizi_3b = np.array([[[1, 2], [3, 4]],
                    [[5, 6], [7, 8]]])
print("3B Dizi shape:", dizi_3b.shape)     # (2, 2, 2)
print("dizi_3b[0, 1, 0]:", dizi_3b[0, 1, 0]) # 0. matris, 1. satÄ±r, 0. sÃ¼tun -> 3

"""#Tek ve Ä°ki Boyutlu Dizilerde EriÅŸim
NumPy'da veri seÃ§imi, Python listelerindeki gibi indeks (konum) numaralarÄ±yla yapÄ±lÄ±r. 2D dizilerde kural: array[satÄ±r, sÃ¼tun].
"""

import numpy as np

# 2D Dizi Ã–rneÄŸi: 3 AylÄ±k SatÄ±ÅŸ Verisi (SatÄ±r: Ay, SÃ¼tun: ÃœrÃ¼n Tipi)
# [A Ã¼rÃ¼nÃ¼, B Ã¼rÃ¼nÃ¼, C Ã¼rÃ¼nÃ¼, D Ã¼rÃ¼nÃ¼]
satislar = np.array([
    [100, 150, 75, 200],  # Ocak (Indeks 0)
    [120, 160, 80, 220],  # Åubat (Indeks 1)
    [110, 145, 90, 210]   # Mart (Indeks 2)
])
print("Orijinal Matris (Shape: 3x4):\n", satislar)

# Ã–rnek 1: Tek Eleman SeÃ§imi
# Åubat (indeks 1) ayÄ±ndaki B Ã¼rÃ¼nÃ¼nÃ¼n (indeks 1) satÄ±ÅŸÄ±
subat_urun_b = satislar[1, 1]
print(f"\nÅubat B ÃœrÃ¼nÃ¼ SatÄ±ÅŸÄ± (1, 1): {subat_urun_b}")
# Ã‡Ä±ktÄ±: 160

# Ã–rnek 2: TÃ¼m SÃ¼tunu SeÃ§me
# D Ã¼rÃ¼nÃ¼nÃ¼n (indeks 3) tÃ¼m aylar boyunca olan satÄ±ÅŸlarÄ±nÄ± Ã§ekme
urun_d_tum_aylar = satislar[:, 3] # TÃ¼m satÄ±rlarÄ± al (:) ve sadece 3. sÃ¼tunu seÃ§
print(f"\nD ÃœrÃ¼nÃ¼nÃ¼n TÃ¼m Aylar SatÄ±ÅŸÄ± (:, 3): {urun_d_tum_aylar}")
# Ã‡Ä±ktÄ±: [200 220 210]

"""**Ã–nemli: NumPy slicing genelde bir view dÃ¶ndÃ¼rÃ¼r â€” kopya deÄŸil. Yani slice Ã¼zerinde yapÄ±lan deÄŸiÅŸiklik orijinal diziyi deÄŸiÅŸtirir**"""

c = np.arange(6)
d = c[1:4]
d[:] = 100
print(c)  # [  0 100 100 100  4  5]

"""# Ã‡ok boyutlu indeksleme (2-D Ã¶rnek)

SatÄ±r ve sÃ¼tun belirtme: arr[row, col].
Ä°ki ayrÄ± kÃ¶ÅŸeli parantez gerekmez (arr[row][col] de Ã§alÄ±ÅŸÄ±r ama arr[row, col] tercih edilir).
"""

M = np.arange(12).reshape(3,4)
# M =
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

print(M[0, 1])    # 1  (0. satÄ±r, 1. sÃ¼tun)
print(M[1])       # [4 5 6 7] (1. satÄ±r tÃ¼m sÃ¼tunlar)
print(M[:, 2])    # [2 6 10] (tÃ¼m satÄ±rlarÄ±n 2. sÃ¼tunu) -> 1D array
print(M[0:2, 1:3])# alt-matris [[1,2],[5,6]]

# Ã–rnek 3: Dilimleme (SatÄ±r ve SÃ¼tun)
# Ocak ve Åubat (indeks 0'dan 2'ye kadar, 2 dahil deÄŸil) A ve B Ã¼rÃ¼nleri (indeks 0'dan 2'ye kadar)
ilk_iki_ay_urun_ab = satislar[0:2, 0:2]
print(f"\nOcak-Åubat, A ve B ÃœrÃ¼nleri:\n{ilk_iki_ay_urun_ab}")
# Ã‡Ä±ktÄ±: [[100 150] [120 160]]

# Ã–rnek 4: Negatif Dilimleme
# En son satÄ±rdan (-1) en sona kadar tÃ¼m sÃ¼tunlarÄ± seÃ§ (Mart ayÄ±)
son_ay = satislar[-1, :]
print(f"\nNegatif Dilimleme (Son Ay): {son_ay}")
# Ã‡Ä±ktÄ±: [110 145 90 210]

"""#Dilimleme ile gÃ¶rÃ¼nÃ¼m (view) vs kopya (copy)

NumPy'da dilimleme ile (sadece : operatÃ¶rÃ¼ kullanÄ±larak) elde edilen alt dizi, orijinal dizinin bellekteki verisine doÄŸrudan eriÅŸim saÄŸlayan bir gÃ¶rÃ¼nÃ¼m (view)'dÃ¼r.


M[0:2, :] â†’ view (varsayÄ±lan, bellek paylaÅŸÄ±lÄ±r).

M[:, 2] â†’ genelde view (ama bazÄ± karmaÅŸÄ±k durumlarda kopya olabilir).

Fancy indexing (aÅŸaÄŸÄ±da) her zaman kopya dÃ¶ndÃ¼rÃ¼r.

Kopya istenirse kopya kullanÄ±n: > `sub = M[0:2, :].copy()`

| Ã–zellik | GÃ¶rÃ¼nÃ¼m (View, Genellikle Dilimleme ile) | Kopya (Copy, Genellikle `.copy()` ile) |
|---------|------------------------------------------|----------------------------------------|
| BaÄŸÄ±mlÄ±lÄ±k | Orijinal diziye baÄŸÄ±mlÄ±dÄ±r. | Orijinal diziden baÄŸÄ±msÄ±zdÄ±r. |
| Bellek | Yeni bir bellek alanÄ± kullanmaz (hÄ±zlÄ±dÄ±r). | Bellekte yeni bir alan tahsis eder (gÃ¼venlidir). |
| Risk | GÃ¶rÃ¼nÃ¼mdeki deÄŸiÅŸiklik, orijinal diziyi bozar. | Orijinal diziye etkisi yoktur. |
"""

# GerÃ§ek Hayat Ã–rneÄŸi: Veri GÃ¼venliÄŸi
ana_veri = np.array([10, 20, 30, 40, 50])
print(f"BaÅŸlangÄ±Ã§: {ana_veri}") # [10 20 30 40 50]

# 1. GÃ–RÃœNÃœM (VIEW) OluÅŸturma (Genellikle Slicing ile)
analiz_view = ana_veri[0:3]

# GÃ¶rÃ¼nÃ¼mdeki ilk elemanÄ± deÄŸiÅŸtiriyoruz.
analiz_view[0] = 999

# SONUÃ‡: Orijinal dizi de deÄŸiÅŸti!
print(f"View sonrasÄ± Orijinal: {ana_veri}")
# Ã‡Ä±ktÄ±: [999 20 30 40 50]  Orijinal verimiz bozuldu!

# 2. KOPYA (COPY) OluÅŸturma
ana_veri_safe = np.array([10, 20, 30, 40, 50])
# GÃ¼venli analiz iÃ§in daima .copy() kullanÄ±n.
analiz_copy = ana_veri_safe[0:3].copy()

# Kopyadaki ilk elemanÄ± deÄŸiÅŸtiriyoruz.
analiz_copy[0] = 888

# SONUÃ‡: Orijinal dizi GÃœVENDE! âœ…
print(f"\nCopy sonrasÄ± Orijinal: {ana_veri_safe}")
# Ã‡Ä±ktÄ±: [10 20 30 40 50]  Orijinal veri deÄŸiÅŸmedi.

"""# Fancy indexing (tamsayÄ± dizisi ile) â€” advanced

Ä°ndeks olarak bir dizi/ndarray kullanÄ±lÄ±r. Bu kopya dÃ¶ndÃ¼rÃ¼r ve sÄ±ra/tekrarÄ± korur.
* EÄŸer satÄ±r ve sÃ¼tun iÃ§in ayrÄ± diziler verirseniz, NumPy eleman-eleman eÅŸleÅŸme yapar (pairwise).

* Tekrarlanan indeksler tekrar eden elemanlar Ã¼retir.
"""

a = np.arange(10)
print(a)
indices = [2,5,5,1]
print(a[indices])   # [2 5 5 1]  (kopya)
print(a)
# 2D Ã¶rnek:
M = np.arange(12).reshape(3,4)
print(M)
rows = np.array([0,2])
cols = np.array([1,3])
print(M[rows, cols]) # [1 11] -> (0,1) ve (2,3) elemanlarÄ±

# GerÃ§ek Hayat Ã–rneÄŸi: Rastgele Ã–rneklem SeÃ§me
isim_indeksleri = np.array(['Ali', 'AyÅŸe', 'Can', 'Deniz', 'Ece', 'Furkan'])
puanlar = np.array([90, 75, 88, 62, 95, 81])

# Sadece 0. (Ali), 4. (Ece) ve 2. (Can) indekslerdeki kiÅŸilerin puanlarÄ±nÄ± Ã§ekmek
indeks_listesi = np.array([0, 4, 2])

secilen_isimler = isim_indeksleri[indeks_listesi]
secilen_puanlar = puanlar[indeks_listesi]

print(f"\nSeÃ§ilen Ä°simler (Rastgele): {secilen_isimler}")
print(f"SeÃ§ilen Puanlar: {secilen_puanlar}")
# Ã‡Ä±ktÄ±: [Ali Ece Can] ve [90 95 88]

"""# Boolean (mask) indexing â€” koÅŸula gÃ¶re seÃ§me

ÅartlÄ± maske ile seÃ§me â€” esnek ve Ã§ok gÃ¼Ã§lÃ¼.

Bir koÅŸulun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ True (SeÃ§) veya False (Atla) deÄŸerlerine gÃ¶re dizi elemanlarÄ±nÄ± filtreleme.
"""

x = np.arange(10)
mask = x % 2 == 0
print(mask)       # [ True False  True ... ]
print(x[mask])    # [0 2 4 6 8]

# Atama:
x[x % 3 == 0] = -1
print(x)  # elemanlarÄ±n bazÄ±larÄ±nÄ±n -1 olduÄŸunu gÃ¶rÃ¼rsÃ¼nÃ¼z

# GerÃ§ek Hayat Ã–rneÄŸi: 5000'den fazla stok adedini filtreleme
stok_adedi = np.array([4500, 6200, 3100, 5800, 9500])

# 1. KoÅŸul Dizisi (Maske) OluÅŸturma
maske = stok_adedi > 5000
print(f"KoÅŸul Maskesi: {maske}")
# Ã‡Ä±ktÄ±: [False True False True True]

# 2. Maskeyi Uygulama (Sadece True olanlar seÃ§ilir)
yuksek_stok = stok_adedi[maske]
print(f"5000 Ã¼zeri Stoklar: {yuksek_stok}")
# Ã‡Ä±ktÄ±: [6200 5800 9500]

"""# Ã‡oklu koÅŸullar (& ve |)

Birden fazla koÅŸulu birleÅŸtirmek iÃ§in Python'daki and ve or yerine, NumPy'Ä±n element-wise operatÃ¶rleri **& (VE) ve | (VEYA)** kullanÄ±lÄ±r.
"""

# GerÃ§ek Hayat Ã–rneÄŸi: MaaÅŸ Filtreleme (50.000 Ã¼zeri VE 5 yÄ±ldan az tecrÃ¼be)
maaslar = np.array([45000, 60000, 75000, 52000, 48000])
tecrube = np.array([7, 3, 6, 2, 8])

# KoÅŸul 1: MaaÅŸ > 50000
maske_maas = maaslar > 50000

# KoÅŸul 2: TecrÃ¼be < 5
maske_tecrube = tecrube < 5

# Ä°ki koÅŸulu BÄ°RLEÅTÄ°RME (VE & operatÃ¶rÃ¼)
filtre_maske = maske_maas & maske_tecrube

# SonuÃ§: Sadece 60000 (3 yÄ±l) ve 52000 (2 yÄ±l) bu koÅŸulu saÄŸlar
hedef_personel_maas = maaslar[filtre_maske]
print(f"\nFiltrelenen Personel MaaÅŸlarÄ± (VE koÅŸulu): {hedef_personel_maas}")
# Ã‡Ä±ktÄ±: [60000 52000]

#karmaÅŸÄ±k Ã¶rnek : boolean + fancy

M = np.arange(12).reshape(3,4)
mask = M % 2 == 0
print(M[mask])  # 2D diziyi boolean mask ile 1D olarak dÃ¶ndÃ¼rÃ¼r

"""# Ellipsis (...) â€” bilinmeyen boyutlar iÃ§in

Bazen boyut sayÄ±sÄ± deÄŸiÅŸkense ... kullanÄ±ÅŸlÄ±dÄ±r.
"""

A = np.zeros((2,3,4,5))
# Ä°lk iki boyutu seÃ§, geri kalanÄ± tÃ¼mÃ¼nÃ¼ al:
print(A)
sub = A[1, ...]   # eÅŸdeÄŸer: A[1, :, :, :]
print("/"*50)
print(sub)

dizi3 = np.arange(24).reshape(2, 3, 4)
print(dizi3)

"""
Boyutlar:

eksen (dÄ±ÅŸ): 2 tane 3x4 matris

eksen (orta): 3 satÄ±r

eksen (iÃ§): 4 sÃ¼tun
"""

#normali
dizi3[:, :, 0]

#ellipsis ile

dizi3[..., 0]

# dÃ¶rt boyutlu dizi

dizi4 = np.arange(2*3*4*5).reshape(2, 3, 4, 5)
print(dizi4)



"""

Bu â†’ ilk eksen 1 (ikinci blok), son eksen 0 (her 3x4â€™lÃ¼k matristen ilk sÃ¼tun).
Yani:

1 â†’ 2. blok

... â†’ aradaki 2 eksenin tÃ¼m elemanlarÄ±

0 â†’ son eksenin ilk elemanÄ±

"""

dizi4[1, ..., 0]

"""# np.newaxis / None â€” eksen ekleme

Boyut (axis) eklemek veya broadcasting iÃ§in kullanÄ±lÄ±r.
Bu genelde broadcasting, vektÃ¶r/matris iÅŸlemleri veya veri ÅŸekillendirme (reshaping) iÃ§in kullanÄ±lÄ±r.

her NumPy dizisinin bir ÅŸekli (shape) vardÄ±r.

np.newaxis kullanarak o ÅŸekle yeni bir eksen eklenir.

np.newaxis ve None aynÄ± ÅŸeyi yapar.
"""

v = np.array([1,2,3])        # shape (3,)
print(v)
v_row = v[np.newaxis, :]     # shape (1,3)
print(v_row)
v_col = v[:, np.newaxis]     # shape (3,1)
print(v_col)

#np.newaxis yerine None da kullanÄ±labilir


dizi = np.array([10,20,30])
print(dizi)
vektor_satir = dizi[:, None]
print(vektor_satir)
vektor_sutun = dizi[None, :]
print(vektor_sutun)

# 2d -> 3D

matris = np.array([
    [1, 2, 3],
    [4, 5, 6]
])
print(matris.shape)
matris_3d = matris[:, :, np.newaxis]
print(matris_3d.shape)
print(matris_3d)

# broadcasting iÃ§in kullanÄ±m
#newaxis, boyutlarÄ± eÅŸitlemek iÃ§in kullanÄ±lÄ±r

a = np.array([1, 2, 3])        # (3,)
b = np.array([10, 20, 30])     # (3,)
print(a*b)
#normalde a*b mÃ¼mkÃ¼m Ã§Ã¼nkÃ¼ ikiside (3,) (3,)

b = b[:, np.newaxis]  # (3, 1)
print(b)
print(a)
print(a*b)
sonuc = a + b
print(sonuc)
print(sonuc.shape)

"""# where, nonzero ile indeks alma

KoÅŸul saÄŸlayan indekslerin pozisyonunu almak isterseniz:
"""

a = np.array([0, 5, 2, 5, 0, 3])
idx = np.where(a == 5)    # (array([1, 3]),)
print(idx[0])             # [1 3]

# nonzero:
print(a.nonzero())        # aynÄ± sonucu verir

"""# Atama ile indeksleme (gÃ¼Ã§lÃ¼ kullanÄ±m)

SeÃ§ilen yerlere deÄŸer atama:

Dikkat: Fancy indexing ile atama bir copy Ã¼zerinde yapÄ±lÄ±rsa orijinal deÄŸiÅŸmez. Ã‡oklu indeksleme ile doÄŸrudan atama yaparken kopya mÄ± yoksa view mi olduÄŸuna dikkat edin.
"""

arr = np.arange(10)
print(arr)
arr[[1,3,5]] = -10
print(arr)  # 1,3,5 indeksleri -10 olur

# boolean ile:
arr[arr < 0] = 0
print(arr)

"""
Ä°ndeksleme ile broadcast (yayÄ±lma) Ã¶rnekleri

Tek bir deÄŸer atamak yerine, uygun ÅŸekle getirilmiÅŸ bir dizi kullanarak broadcasting yapabilirsiniz:
"""

M = np.zeros((3,4))
M[:, 1] = np.array([1,2,3])   # shape (3,) ile sÃ¼tuna atama â†’ broadcast deÄŸil, doÄŸrudan uyan shape
# veya
M[np.array([0,1,2]), 2] = [10,20,30]  # eleman-eleman atama

"""
Ã‡ok boyutlu ilerleme (advanced slicing)

AdÄ±m ve negatif step de 2D/3Dâ€™de kullanÄ±labilir.

"""
M = np.arange(16).reshape(4,4)

print(M[::2, ::2])   # her 2. satÄ±r ve sÃ¼tun
print(M[::-1, ::-1]) # tersine dÃ¶ndÃ¼rÃ¼lmÃ¼ÅŸ matris

"""#Dilimleme vs Fancy â€” performans farkÄ±

Slicing â†’ view, hafÄ±za paylaÅŸÄ±mÄ± â€” hÄ±zlÄ±, hafÄ±za verimli.

Fancy / boolean â†’ kopya â€” gerektiÄŸinde hÄ±zlÄ± ve esnek ama bellek kullanÄ±mÄ± artar.
"""

#Ã§ok boyutlu fancy indexing Ã¶rneÄŸi

M = np.arange(12).reshape(3,4)
print(M)
rows = [0,1]
cols = [1,2]
print(M[rows][:, cols])   # farklÄ± sonuÃ§: M[rows] Ã¶nce alt-matris (kopya) verir, sonra sÃ¼tun seÃ§ilir
print(M[np.ix_(rows, cols)])  # doÄŸru ÅŸekilde (0,1) ve (1,2) alt-matrisini verir

#np.ix_ kombinasyonu, iki 1-D indeks listesiyle 2-D alt-matris almak iÃ§in kullanÄ±lÄ±r.

"""## âš ï¸ YaygÄ±n Tuzaklar / Dikkat Edilmesi Gerekenler

- **Slicing view dÃ¶ndÃ¼rÃ¼r** â€” dilim Ã¼zerinden yaptÄ±ÄŸÄ±nÄ±z deÄŸiÅŸiklik **orijinali deÄŸiÅŸtirir**.  
  â†’ EÄŸer kopya istiyorsanÄ±z `.copy()` kullanÄ±n.

- **Fancy indexing kopya dÃ¶ndÃ¼rÃ¼r** â€” bu nedenle bÃ¼yÃ¼k dizilerde **bellek kullanÄ±mÄ± artar.**

- **Boolean indexing** kullanÄ±rken orijinalin `shape`â€™i bozulur:  
  â†’ `M[mask]` genelde **1D** dÃ¶ndÃ¼rÃ¼r.

- **AdÄ±m (step) float olamaz** â€” slice adÄ±mÄ± sadece **integer** olabilir.  
  â†’ OndalÄ±k adÄ±mlar istenirse `np.linspace` kullanÄ±n.

- **Atama yaparken shape uyumu gereklidir** â€” broadcasting kurallarÄ±na uymazsa **hata verir.**

- `M[rows][:, cols]` ile `M[rows, cols]` veya `M[np.ix_(rows, cols)]` **farklÄ± davranÄ±r** â€” dikkat!

---

## ğŸ§° KullanÄ±ÅŸlÄ± Ä°puÃ§larÄ± & YardÄ±mcÄ± Fonksiyonlar

- `np.take(a, indices, axis=...)` â€” fancy indexing alternatifi, belirli bir eksen Ã¼zerinden alma.  
- `np.put(a, indices, values, mode='raise')` â€” belirli konumlara deÄŸer yerleÅŸtirme.  
- `np.choose`, `np.compress`, `np.extract` â€” belirli seÃ§im iÅŸlemleri iÃ§in.  
- `np.argwhere(condition)` â€” koÅŸulu saÄŸlayan **indeksleri (satÄ±r-sÃ¼tun Ã§iftleri)** dÃ¶ndÃ¼rÃ¼r.

---

## ğŸ§¾ Ã–zet â€” KÄ±sa Referans

| YazÄ±m | AÃ§Ä±klama |
|-------|-----------|
| `a[i]` | Tek indeks |
| `a[start:stop:step]` | Slice (view) |
| `a[rows, cols]` | Ã‡ok boyutlu doÄŸrudan indeksleme |
| `a[[i1, i2]]` | Fancy indexing (kopya) |
| `a[mask]` | Boolean indexing (kopya) |
| `a[..., i]` | Ellipsis (tÃ¼m eksenleri kapsar) |
| `a[np.newaxis]` veya `a[None]` | Eksen ekleme |
| `np.where`, `np.nonzero` | Ä°ndeks/konum bulma |
| `np.ix_` | 2D / ND iÃ§in Ã§apraz tamsayÄ± indeksleme |

"""

# =========================
# JUPYTER NOTEBOOK: NumPy Ä°ndeksleme
# =========================

import numpy as np

# --------------------------------
# 1. 1D Dizi ve Temel Ä°ndeksleme
# --------------------------------
print("1ï¸âƒ£ 1D Dizi ve Temel Ä°ndeksleme")
a = np.arange(10)
print("Dizi a:", a)

print("\na[0] ->", a[0])
print("a[-1] ->", a[-1])
print("a[3] ->", a[3])

# --------------------------------
# 2. Dilimleme / Slicing
# --------------------------------
print("\n2ï¸âƒ£ Dilimleme / Slicing")
print("a[2:7] ->", a[2:7])
print("a[:5] ->", a[:5])
print("a[5:] ->", a[5:])
print("a[::2] ->", a[::2])
print("a[::-1] ->", a[::-1])

# Slice view Ã¶rneÄŸi
b = a[2:5]
b[:] = 100
print("Slice b = a[2:5], b[:] = 100 â†’ a dizisi:", a)

# --------------------------------
# 3. 2D Dizi ve Ã‡ok Boyutlu Ä°ndeksleme
# --------------------------------
print("\n3ï¸âƒ£ 2D Dizi ve Ã‡ok Boyutlu Ä°ndeksleme")
M = np.arange(12).reshape(3,4)
print("Dizi M:\n", M)

print("M[0, 1] ->", M[0,1])
print("M[1] ->", M[1])
print("M[:, 2] ->", M[:,2])
print("M[0:2, 1:3] ->\n", M[0:2,1:3])

# --------------------------------
# 4. Fancy Indexing (TamsayÄ± ile)
# --------------------------------
print("\n4ï¸âƒ£ Fancy Indexing")
rows = [0,2]
cols = [1,3]
print("M[rows, cols] ->", M[rows, cols])

# --------------------------------
# 5. Boolean Indexing
# --------------------------------
print("\n5ï¸âƒ£ Boolean Indexing")
mask = M % 2 == 0
print("Mask (Ã§ift sayÄ±lar):\n", mask)
print("M[mask] ->", M[mask])

# Atama Ã¶rneÄŸi
M[M % 3 == 0] = -1
print("M dizisi (3 ile bÃ¶lÃ¼nebilenler -1 oldu):\n", M)

# --------------------------------
# 6. np.ix_ ile Ã§apraz fancy indexing
# --------------------------------
rows = [0,1]
cols = [1,2]
sub = M[np.ix_(rows, cols)]
print("\n6ï¸âƒ£ np.ix_ ile alt-matris:\n", sub)

# --------------------------------
# 7. np.newaxis / None ile eksen ekleme
# --------------------------------
v = np.array([1,2,3])
v_row = v[np.newaxis, :]
v_col = v[:, np.newaxis]
print("\n7ï¸âƒ£ Ekseni deÄŸiÅŸtirme / np.newaxis")
print("v shape:", v.shape)
print("v_row shape:", v_row.shape)
print("v_row:\n", v_row)
print("v_col shape:", v_col.shape)
print("v_col:\n", v_col)

# --------------------------------
# 8. where ve nonzero ile indeks alma
# --------------------------------
a = np.array([0,5,2,5,3])
idx_where = np.where(a==5)
idx_nonzero = a.nonzero()
print("\n8ï¸âƒ£ np.where ve nonzero")
print("np.where(a==5) ->", idx_where[0])
print("a.nonzero() ->", idx_nonzero[0])

# --------------------------------
# 9. KarmaÅŸÄ±k slicing Ã¶rnekleri
# --------------------------------
M = np.arange(16).reshape(4,4)
print("\n9ï¸âƒ£ KarmaÅŸÄ±k slicing Ã¶rnekleri")
print("M dizisi:\n", M)
print("M[::2, ::2] ->\n", M[::2, ::2])
print("M[::-1, ::-1] ->\n", M[::-1, ::-1])

# --------------------------------
# 10. Mini uygulama: Dizi seÃ§me ve deÄŸiÅŸtirme
# --------------------------------
print("\nğŸ”Ÿ Mini Uygulama")
arr = np.arange(1, 21).reshape(4,5)
print("BaÅŸlangÄ±Ã§ dizisi:\n", arr)

# 2. satÄ±r ve 3. sÃ¼tundaki elemanÄ± 99 yap
arr[1,2] = 99
# tÃ¼m Ã§ift sayÄ±larÄ± -1 yap
arr[arr % 2 == 0] = -1
print("GÃ¼ncellenmiÅŸ dizi:\n", arr)

#Genel Ã–rnek 2

# DetaylÄ± Dilimleme Ã–rnekleri
dizi = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print("Orijinal dizi:", dizi)

# Temel dilimleme
print("dizi[2:7]:", dizi[2:7])           # [2, 3, 4, 5, 6]
print("dizi[:5]:", dizi[:5])             # Ä°lk 5 eleman [0, 1, 2, 3, 4]
print("dizi[5:]:", dizi[5:])             # 5'ten sonra [5, 6, 7, 8, 9]
print("dizi[::2]:", dizi[::2])           # Bir atlayarak [0, 2, 4, 6, 8]
print("dizi[::-1]:", dizi[::-1])         # Ters Ã§evir [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
print("---")

# 2B Dizide Dilimleme
matrix = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8],
                  [9, 10, 11, 12],
                  [13, 14, 15, 16]])
print("Orijinal matrix:\n", matrix)

# SatÄ±r dilimleme
print("Ä°lk 2 satÄ±r:\n", matrix[:2, :])           # SatÄ±r 0 ve 1
print("Son satÄ±r:\n", matrix[-1, :])             # Son satÄ±r
print("Ã‡ift indeksli satÄ±rlar:\n", matrix[::2, :]) # 0, 2. satÄ±rlar

# SÃ¼tun dilimleme
print("Ä°lk 2 sÃ¼tun:\n", matrix[:, :2])           # SÃ¼tun 0 ve 1
print("Son sÃ¼tun:\n", matrix[:, -1])             # Son sÃ¼tun
print("Bir atlayarak sÃ¼tunlar:\n", matrix[:, ::2]) # 0, 2. sÃ¼tunlar

# Hem satÄ±r hem sÃ¼tun dilimleme
print("2x2 alt matrix:\n", matrix[1:3, 1:3])     # SatÄ±r 1-2, SÃ¼tun 1-2
print("---")

# VIEW vs COPY - KRÄ°TÄ°K KONU!
print("=== VIEW vs COPY ===")
original = np.array([10, 20, 30, 40, 50])

# VIEW oluÅŸturma (veri paylaÅŸÄ±r)
view_dizi = original[1:4]                # Dilimleme VIEW dÃ¶ndÃ¼rÃ¼r
print("Original:", original)
print("View:", view_dizi)

# View'de deÄŸiÅŸiklik original'i etkiler!
view_dizi[0] = 999
print("View deÄŸiÅŸtikten sonra Original:", original)  # [10, 999, 30, 40, 50]

# COPY oluÅŸturma (yeni veri)
original[1] = 20  # Eski haline getir
copy_dizi = original[1:4].copy()         # .copy() ile kopya oluÅŸtur
print("Copy:", copy_dizi)

# Copy'de deÄŸiÅŸiklik original'i ETKÄ°LEMEZ!
copy_dizi[0] = 888
print("Copy deÄŸiÅŸtikten sonra Original:", original)  # DeÄŸiÅŸmez [10, 20, 30, 40, 50]
print("---")

# Hangi durumlarda COPY oluÅŸur?
print("Dilimleme â†’ VIEW")
print("Boolean indeksleme â†’ COPY")
print("Fancy indeksleme â†’ COPY")
print(".copy() metodu â†’ COPY")

# Boolean indeksleme COPY dÃ¶ndÃ¼rÃ¼r
bool_mask = original > 25
bool_selection = original[bool_mask]     # Bu bir COPY!
print("Boolean selection is copy?", bool_selection.base is None)  # True

"""#Dizileri tekrar ÅŸekillendirmek

Elimizde bulunan tek boyutlu veya Ã§ok boyutlu dizileri tekrar boyut ayarlamasÄ± yapmak isteyebilirzi bu gibi durumlarda reshape Ã¶zelliÄŸi kullanabiliriz
"""

import numpy as np
dizi = np.arange(1,16)
print(dizi)

print(dizi.reshape(3,5))

dizi = np.arange(1,21).reshape(4,5)
dizi

# randint ve reshape ile rastgele sayÄ±lardan matris oluÅŸturma

# 0 ile 100 arasÄ±nda 12 adet rastgele tam sayÄ± Ã¼ret
rastgele_sayilar = np.random.randint(0, 101, 12)
print("OluÅŸturulan rastgele 1D dizi:", rastgele_sayilar)

# 1D diziyi 3 satÄ±r ve 4 sÃ¼tunlu bir matrise dÃ¶nÃ¼ÅŸtÃ¼r
matris_yeniden_sekillendirilmis = rastgele_sayilar.reshape(3, 4)
print("\nYeniden ÅŸekillendirilmiÅŸ 2D matris:\n", matris_yeniden_sekillendirilmis)

# GerÃ§ek Hayat Ã–rneÄŸi: SensÃ¶r Verisinin 1D'den 2D'ye Ã‡evrilmesi
# Bir saatte 6 saniyede bir alÄ±nan 30 adet Ã¶lÃ§Ã¼m.
olcumler_1d = np.arange(30)
print(f"BaÅŸlangÄ±Ã§ Shape: {olcumler_1d.shape}") # (30,)

# 1. 5 SatÄ±r, 6 SÃ¼tun Yapma (5 dakikalÄ±k 6 periyot)
matris_5x6 = olcumler_1d.reshape(5, 6)
print(f"\n5x6 Matris:\n{matris_5x6}")

# 2. Otomatik Hesaplama iÃ§in -1 KullanÄ±mÄ±
# SÃ¼tun sayÄ±sÄ±nÄ± 10 olarak belirle, satÄ±rÄ± NumPy hesaplasÄ±n (30/10=3).
matris_otomatik_satir = olcumler_1d.reshape(-1, 10)
print(f"\nOtomatik SatÄ±r (Shape: {matris_otomatik_satir.shape}):\n{matris_otomatik_satir}")
# Ã‡Ä±ktÄ±: (3, 10)

# 3. Model Girdisi FormatÄ± (Ã–zellik VektÃ¶rÃ¼)
# 1D vektÃ¶rÃ¼, makine Ã¶ÄŸrenimi iÃ§in (30, 1) ÅŸeklinde 2D matrise Ã§evirme
vektor_sutun = olcumler_1d.reshape(-1, 1)
print(f"\n(30, 1) SutÃ¼n VektÃ¶r Shape: {vektor_sutun.shape}")

"""#arraylerde birleÅŸtirme

| Fonksiyon           | AÃ§Ä±klama                                                                        |
| ------------------- | ------------------------------------------------------------------------------- |
| `np.concatenate()`  | Dizileri belirli bir axis boyunca birleÅŸtirir.                                  |
| `np.vstack()`       | Dizileri **dikey** olarak Ã¼st Ã¼ste birleÅŸtirir (row-wise).                      |
| `np.hstack()`       | Dizileri **yatay** olarak yan yana birleÅŸtirir (column-wise).                   |
| `np.stack()`        | Yeni bir eksen (axis) ekleyerek birleÅŸtirir.                                    |
| `np.column_stack()` | 1D dizileri **sÃ¼tun olarak** birleÅŸtirir, 2D dizilerde yatay birleÅŸtirme yapar. |
| `np.row_stack()`    | `vstack` ile aynÄ± iÅŸlevi gÃ¶rÃ¼r.                                                 |

**Tek boyutlu dizilerde birleÅŸtirme**
"""

dizi1 =  np.array([1,2,3,4,5])
dizi2 =  np.array([10,20,30,40,50])

#birleÅŸtirmek iÃ§in
np.concatenate([dizi1, dizi2])
#np.concatenate([dizi1, dizi2,dizi3,....]) Ã§ok sayÄ±da diziyi birleÅŸtirebiliriz

import numpy as np

a = np.array([1,2,3])
b = np.array([4,5,6])

# concatenate
c = np.concatenate([a,b])
print("concatenate:", c)

# hstack
d = np.hstack([a,b])
print("hstack:", d)

# vstack
e = np.vstack([a,b])
print("vstack:\n", e)

"""**Ã§ok boyutlu dizileri birleÅŸtirme**"""

dizi1=np.array([[1,2,3],[4,5,6]])
dizi2=np.array([[7,8,9],[10,11,12]])

np.concatenate([dizi1, dizi2])

X = np.array([[1,2],[3,4]])
Y = np.array([[5,6],[7,8]])

# axis=0 â†’ satÄ±rlarÄ± birleÅŸtirir (alt alta)
print("concatenate axis=0:\n", np.concatenate([X,Y], axis=0))

# axis=1 â†’ sÃ¼tunlarÄ± birleÅŸtirir (yan yana)
print("concatenate axis=1:\n", np.concatenate([X,Y], axis=1))

# vstack â†’ axis=0 ile aynÄ±
print("vstack:\n", np.vstack([X,Y]))

# hstack â†’ axis=1 ile aynÄ±
print("hstack:\n", np.hstack([X,Y]))

"""
np.stack() â€” Yeni eksen ile birleÅŸtirme

stack, dizileri yeni bir boyut ekleyerek birleÅŸtirir.

"""
X = np.array([1,2,3])
Y = np.array([4,5,6])

Z = np.stack([X,Y], axis=0)
print("axis=0 ile stack:\n", Z)
print("shape:", Z.shape)

Z2 = np.stack([X,Y], axis=1)
print("axis=1 ile stack:\n", Z2)
print("shape:", Z2.shape)

#column_stack ve row_stack

a = np.array([1,2,3])
b = np.array([4,5,6])

# sÃ¼tun olarak birleÅŸtirme
print("column_stack:\n", np.column_stack([a,b]))

# row_stack â†’ vstack ile aynÄ±
print("row_stack:\n", np.row_stack([a,b]))

"""| Fonksiyon      | 1D Dizi | 2D Dizi | Yeni Boyut?             |
| -------------- | ------- | ------- | ----------------------- |
| `concatenate`  | âœ”       | âœ”       | âŒ                       |
| `vstack`       | âœ”       | âœ”       | âŒ (axis=0)              |
| `hstack`       | âœ”       | âœ”       | âŒ (axis=1)              |
| `stack`        | âœ”       | âœ”       | âœ” (axis ile yeni boyut) |
| `column_stack` | âœ”       | âœ”       | âŒ                       |
| `row_stack`    | âœ”       | âœ”       | âŒ                       |


Ä°pucu:

1D dizilerde hstack = concatenate, vstack â†’ 2D dizi

2D dizilerde axis=0 â†’ satÄ±r, axis=1 â†’ sÃ¼tun
"""

# =========================
# JUPYTER NOTEBOOK: NumPy Dizileri BirleÅŸtirme
# =========================
import numpy as np

print("ğŸ”¹ NumPy Dizileri BirleÅŸtirme AracÄ±")

# -----------------------------
# 1ï¸âƒ£ KullanÄ±cÄ±dan dizileri oluÅŸtur
# -----------------------------
print("\nOluÅŸturulacak ilk diziyi belirtin (Ã¶rn: 1,2,3,4):")
dizi1_str = input("Dizi 1: ")
dizi1 = np.array([int(x.strip()) for x in dizi1_str.split(",")])

print("OluÅŸturulacak ikinci diziyi belirtin (Ã¶rn: 5,6,7,8):")
dizi2_str = input("Dizi 2: ")
dizi2 = np.array([int(x.strip()) for x in dizi2_str.split(",")])

# Dizi boyutlarÄ±nÄ± isteÄŸe gÃ¶re deÄŸiÅŸtirebilirsiniz
reshape_input = input("\nDizileri 2D yapmak ister misiniz? (evet/hayÄ±r): ").strip().lower()
if reshape_input == "evet":
    rows1 = int(input("Dizi 1 iÃ§in satÄ±r sayÄ±sÄ±: "))
    cols1 = int(input("Dizi 1 iÃ§in sÃ¼tun sayÄ±sÄ±: "))
    dizi1 = dizi1.reshape(rows1, cols1)

    rows2 = int(input("Dizi 2 iÃ§in satÄ±r sayÄ±sÄ±: "))
    cols2 = int(input("Dizi 2 iÃ§in sÃ¼tun sayÄ±sÄ±: "))
    dizi2 = dizi2.reshape(rows2, cols2)

print("\nDizi 1:\n", dizi1)
print("Dizi 2:\n", dizi2)

# -----------------------------
# 2ï¸âƒ£ BirleÅŸtirme yÃ¶ntemini seÃ§
# -----------------------------
print("\nBirleÅŸtirme yÃ¶ntemi seÃ§enekleri:")
print("1: concatenate (axis belirtin)")
print("2: vstack")
print("3: hstack")
print("4: stack (axis belirtin)")
print("5: column_stack")
print("6: row_stack")

secim = input("SeÃ§iminiz (1-6): ").strip()

if secim == "1":
    axis = int(input("concatenate iÃ§in axis (0 veya 1): "))
    sonuc = np.concatenate([dizi1, dizi2], axis=axis)
elif secim == "2":
    sonuc = np.vstack([dizi1, dizi2])
elif secim == "3":
    sonuc = np.hstack([dizi1, dizi2])
elif secim == "4":
    axis = int(input("stack iÃ§in axis (0,1,...): "))
    sonuc = np.stack([dizi1, dizi2], axis=axis)
elif secim == "5":
    sonuc = np.column_stack([dizi1, dizi2])
elif secim == "6":
    sonuc = np.row_stack([dizi1, dizi2])
else:
    print("GeÃ§ersiz seÃ§im")
    sonuc = None

# -----------------------------
# 3ï¸âƒ£ Sonucu gÃ¶ster
# -----------------------------
if sonuc is not None:
    print("\nâœ… BirleÅŸtirilmiÅŸ Dizi:\n", sonuc)
    print("Shape:", sonuc.shape)

#farkli dizileri dikey ve yatayda birlÅŸtirme

# Ä°ki FarklÄ± BÃ¶lgeden Gelen AylÄ±k SÄ±caklÄ±k Verisi
bolge_a_sicaklik = np.array([20, 22, 21])
bolge_b_sicaklik = np.array([18, 20, 19])

# Dikey BirleÅŸtirme (axis=0): Veriyi alt alta ekle (SatÄ±r bazÄ±nda)
birlesik_dikey = np.concatenate([bolge_a_sicaklik, bolge_b_sicaklik], axis=0)
print(f"Dikey BirleÅŸtirme: {birlesik_dikey}")
# Ã‡Ä±ktÄ±: [20 22 21 18 20 19]

# Yatay BirleÅŸtirme (axis=1): SÃ¼tun bazÄ±nda (Ã–zellik ekleme)
# 2D formatÄ±na Ã§eviriyoruz ki sÃ¼tun bazÄ±nda birleÅŸtirebilelim
A_matris = bolge_a_sicaklik.reshape(-1, 1) # (3, 1)
B_matris = bolge_b_sicaklik.reshape(-1, 1) # (3, 1)

birlesik_yatay = np.concatenate([A_matris, B_matris], axis=1)
print(f"\nYatay BirleÅŸtirme (Shape: {birlesik_yatay.shape}):\n{birlesik_yatay}")
# Ã‡Ä±ktÄ±: [[20 18] [22 20] [21 19]] (AynÄ± Ã¶lÃ§Ã¼m anÄ±nÄ±n A ve B bÃ¶lgesi verisi)

"""# **Dizilerde BÃ¶lme Ä°ÅŸlemleri**

| Fonksiyon          | AÃ§Ä±klama                                                                           |
| ------------------ | ---------------------------------------------------------------------------------- |
| `np.split()`       | Diziyi **belirtilen indekslerden** bÃ¶ler.                                          |
| `np.array_split()` | Diziyi **yaklaÅŸÄ±k eÅŸit parÃ§alar** halinde bÃ¶ler. (splitâ€™de tam bÃ¶lÃ¼nme ÅŸart deÄŸil) |
| `np.hsplit()`      | Ã‡ok boyutlu dizileri **sÃ¼tun bazlÄ±** bÃ¶ler (axis=1).                               |
| `np.vsplit()`      | Ã‡ok boyutlu dizileri **satÄ±r bazlÄ±** bÃ¶ler (axis=0).                               |
| `np.dsplit()`      | 3D ve Ã¼stÃ¼ dizileri **derinlik ekseni** boyunca bÃ¶ler (axis=2).                    |

"""

# 1d dizilerde bÃ¶lme

import numpy as np

a = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]

# np.split ile indekslerden bÃ¶lme
print("np.split([3,7]):", np.split(a, [3,7]))
# 0:3, 3:7, 7:end â†’ [[0 1 2], [3 4 5 6], [7 8 9]]

# np.array_split ile yaklaÅŸÄ±k eÅŸit parÃ§alar
print("np.array_split(3):", np.array_split(a, 3))
# yaklaÅŸÄ±k eÅŸit 3 parÃ§a â†’ [[0 1 2 3], [4 5 6], [7 8 9]]

#Fark: np.split sadece tam bÃ¶lÃ¼nebilen dizilerde Ã§alÄ±ÅŸÄ±r; np.array_split ise kalanlarÄ± dengeler.

# 2d dizilerde bÃ¶lme

M = np.arange(16).reshape(4,4)
print("Dizi M:\n", M)

# SatÄ±r bazlÄ± bÃ¶lme (vsplit)
print("vsplit 2 parÃ§aya:\n", np.vsplit(M, 2))

# SÃ¼tun bazlÄ± bÃ¶lme (hsplit)
print("hsplit 2 parÃ§aya:\n", np.hsplit(M, 2))

"""
Ã‡ok Boyutlu Dizilerde BÃ¶lme

dsplit â†’ 3D dizilerde derinlik ekseni boyunca

hsplit â†’ axis=1

vsplit â†’ axis=0
"""

A = np.arange(24).reshape(2,3,4)  # shape (2,3,4)
print(A)
print("dsplit 2 parÃ§aya:\n", np.dsplit(A, 2))

#diziyi satÄ±r sÃ¼tÃ¼n olarka bÃ¶l

M = np.arange(1,17).reshape(4,4)
print("Orijinal dizi:\n", M)

satir_parcalari = np.vsplit(M, 2)
sutun_parcalari = np.hsplit(M, 2)

print("\nSatÄ±r bazlÄ± 2 parÃ§a:")
for p in satir_parcalari:
    print(p)

print("\nSÃ¼tun bazlÄ± 2 parÃ§a:")
for p in sutun_parcalari:
    print(p)

"""**Dikkat**
1. split tam bÃ¶lÃ¼nme ister. BÃ¶lÃ¼nemiyorsa hata verir.

`np.split(np.arange(10), 3)  # HATA!`


2. array_split â†’ yaklaÅŸÄ±k eÅŸit parÃ§alara bÃ¶ler, kalanlarÄ± dengeler.

`np.array_split(np.arange(10), 3)  # [[0 1 2 3], [4 5 6], [7 8 9]]`


3. hsplit ve vsplit â†’ 2D veya daha fazla boyutlu dizilerde kolay kullanÄ±m saÄŸlar.

# Transpose Nedir ?

Transpose, bir matrisin satÄ±r ve sÃ¼tunlarÄ±nÄ± yer deÄŸiÅŸtirme iÅŸlemidir.

2D dizilerde: M.T â†’ satÄ±rlar sÃ¼tun, sÃ¼tunlar satÄ±r olur.

ND dizilerde: np.transpose â†’ istenirse eksenlerin sÄ±rasÄ± deÄŸiÅŸtirilebilir.
"""

#2d dizilerde transpose

import numpy as np

M = np.array([[1,2,3],
              [4,5,6]])
print("Orijinal Dizi:\n", M)

# Transpose
MT = M.T
print("\nTranspoze:\n", MT)

#1d transpose

v = np.array([1,2,3])
print("v:", v)
print("v.T:", v.T)

"""
3D veya ND Dizilerde Transpose

3D dizilerde veya daha Ã¼st boyutlarda np.transpose ile ekseni deÄŸiÅŸtirebilirsin.
"""
A = np.arange(24).reshape(2,3,4)
print("Orijinal shape:", A.shape)

# Eksenleri deÄŸiÅŸtir (0,2,1)
B = np.transpose(A, (0,2,1))
print("Yeni shape:", B.shape)

#Orijinal shape: (2,3,4) â†’ Yeni shape: (2,4,3)
#Ekseni (0,2,1) ile ilk ekseni koruduk, ikinci ve Ã¼Ã§Ã¼ncÃ¼ ekseni yer deÄŸiÅŸtirdik.

#transpose vs swapaxes

#transpose â†’ tÃ¼m eksenleri yeniden sÄ±ralama
#swapaxes â†’ sadece iki ekseni deÄŸiÅŸtirir

C = np.arange(12).reshape(2,3,2)
print("Orijinal shape:", C.shape)
print(C)

D = C.swapaxes(1,2)
print("swapaxes(1,2) shape:", D.shape)
print(D)

"""# Matris Ã‡arpÄ±mÄ± (np.dot / @) (EK KONU)
Oturum 1'deki * (element-wise Ã§arpÄ±m) ile karÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r. Matris Ã‡arpÄ±mÄ±, Lineer Cebir kurallarÄ±na uyar.


"""

X = np.array([[1,2,3],
              [4,5,6]])

# Transpoze ile matris Ã§arpÄ±mÄ±
XT = X.T
print("X.T @ X:\n", XT @ X)

# GerÃ§ek Hayat Ã–rneÄŸi: AÄŸÄ±rlÄ±klÄ± Ortalama/Skor Hesaplama
# Matris A: 4 Ã¶ÄŸrencinin 2 dersten aldÄ±ÄŸÄ± puan (4x2)
puanlar = np.array([[90, 70], [80, 60], [75, 85], [95, 75]])

# VektÃ¶r B: Derslerin Kredileri/AÄŸÄ±rlÄ±klarÄ± (2x1)
krediler = np.array([[0.6], [0.4]]) # Krediler [Ders1, Ders2]

# Matris Ã‡arpÄ±mÄ± (np.dot veya @)
# (4x2) @ (2x1) = (4x1) -> Her Ã¶ÄŸrencinin toplam aÄŸÄ±rlÄ±klÄ± puanÄ±
toplam_puan = puanlar @ krediler
# VEYA: toplam_puan = np.dot(puanlar, krediler)

print(f"AÄŸÄ±rlÄ±klÄ± Puanlar (Matris Ã‡arpÄ±mÄ± Sonucu):\n{toplam_puan.round(2)}")
# Ã‡Ä±ktÄ±:
# [[82.0]  (90*0.6 + 70*0.4)
#  [72.0]
#  [79.0]
#  [87.0]]

"""# Tekrar KodlarÄ±"""

# 1. VIEW vs COPY FarkÄ±nÄ± Anla - PERFORMANS KRÄ°TÄ°K!
dizi = np.array([1, 2, 3, 4, 5])
view = dizi[1:4]    # VIEW - hÄ±zlÄ±, bellek verimli
copy = dizi[1:4].copy()  # COPY - yavaÅŸ, fazla bellek

# 2. Boolean Indexing'de Parantez Kullan
# YANLIÅ: dizi > 5 and dizi < 10
# DOÄRU: (dizi > 5) & (dizi < 10)

# 3. BÃ¼yÃ¼k Dizilerde .copy() KullanÄ±mÄ±na Dikkat Et
buyuk_dizi = np.random.rand(1000000)
# KÃ¶tÃ¼: yeni_dizi = buyuk_dizi[::2]  # VIEW, orijinali silinemez
# Ä°yi: yeni_dizi = buyuk_dizi[::2].copy()  # COPY, orijinal silinebilir

# 4. reshape()'te -1 Kullanarak Kodunu Esnek Yap
dizi = np.arange(24)
otomatik = dizi.reshape(2, 3, -1)  # NumPy 4 hesaplar: 24/(2*3)=4

# 5. Rastgele SayÄ±larda seed() Kullan - ReprodÃ¼cibility
np.random.seed(42)  # AynÄ± sonuÃ§larÄ± garanti eder

# 6. Boolean Maskeleri Ã–nceden Hesapla - OKUNABÄ°LÄ°RLÄ°K
dizi = np.random.rand(1000)
kosul = (dizi > 0.3) & (dizi < 0.7)
sonuc = dizi[kosul]  # Daha okunabilir

# 7. Fancy Indexing Yerine Boolean Indexing Tercih Et - PERFORMANS
# Daha hÄ±zlÄ±: dizi[dizi > 5]
# Daha yavaÅŸ: dizi[[i for i in range(len(dizi)) if dizi[i] > 5]]

# 8. Ã‡ok Boyutlu Dizilerde axis Parametresini DoÄŸru Anla
matrix = np.random.rand(3, 4)
toplam_satir = matrix.sum(axis=1)  # SatÄ±rlar boyunca
toplam_sutun = matrix.sum(axis=0)  # SÃ¼tunlar boyunca

# 9. BÃ¼yÃ¼k Dizileri Ä°ÅŸlerken Bellek KullanÄ±mÄ±nÄ± Ä°zle
import sys
dizi = np.ones((1000, 1000))
print(f"Bellek kullanÄ±mÄ±: {dizi.nbytes / 1024 / 1024:.2f} MB")

# 10. np.where() ile KoÅŸullu Ä°ÅŸlemleri VektÃ¶rel Yap
dizi = np.array([1, 2, 3, 4, 5])
# KÃ¶tÃ¼: [x if x > 3 else 0 for x in dizi]  # Python dÃ¶ngÃ¼sÃ¼ - yavaÅŸ
# Ä°yi: np.where(dizi > 3, dizi, 0)  # VektÃ¶rel iÅŸlem - hÄ±zlÄ±

"""**ileri dilimleme teknikleri**"""

# np.newaxis - Boyut Ekleme
dizi = np.array([1, 2, 3])
print("Orijinal shape:", dizi.shape)  # (3,)
print("newaxis ile sÃ¼tun vektÃ¶rÃ¼:", dizi[:, np.newaxis].shape)  # (3, 1)
print("newaxis ile satÄ±r vektÃ¶rÃ¼:", dizi[np.newaxis, :].shape)  # (1, 3)

# np.ix_ - KarmaÅŸÄ±k Indexing
matrix = np.arange(25).reshape(5, 5)
rows = [1, 3, 4]
cols = [0, 2, 4]
print("ix_ ile seÃ§im:\n", matrix[np.ix_(rows, cols)])

"""# np.put ve np.take"""

# np.put - Belirli indekslere deÄŸer atama
dizi = np.array([10, 20, 30, 40, 50])
np.put(dizi, [0, 2, 4], [100, 300, 500])
print("put sonrasÄ±:", dizi)  # [100, 20, 300, 40, 500]

# np.take - Belirli indekslerden deÄŸer alma
alinan = np.take(dizi, [1, 3])
print("take ile alÄ±nan:", alinan)  # [20, 40]

"""
* Ã¶rnek 1 Hisse senedi fiyat analizi

"""

import numpy as np

# GerÃ§ek hayat senaryosu: Bir hisse senedinin 10 gÃ¼nlÃ¼k kapanÄ±ÅŸ fiyatlarÄ±nÄ± analiz etme
print("=== Ã–RNEK 1: Hisse Senedi Fiyat Analizi ===")

# 10 gÃ¼nlÃ¼k hisse senedi kapanÄ±ÅŸ fiyatlarÄ± (TL)
gunluk_fiyatlar = [145.50, 148.20, 152.75, 149.30, 155.80, 153.25, 158.90, 162.40, 159.75, 164.20]
hisse_fiyatlari = np.array(gunluk_fiyatlar)

print(f"10 gÃ¼nlÃ¼k hisse fiyatlarÄ±: {hisse_fiyatlari}")
print(f"Veri tipi: {hisse_fiyatlari.dtype}")  # float64 - ondalÄ±klÄ± sayÄ±lar iÃ§in uygun
print(f"Boyut: {hisse_fiyatlari.shape}")     # (10,) - 10 elemanlÄ± 1B dizi

# GÃ¼nlÃ¼k getiri oranlarÄ±nÄ± hesapla (yÃ¼zde deÄŸiÅŸim)
getiri_oranlari = (hisse_fiyatlari[1:] - hisse_fiyatlari[:-1]) / hisse_fiyatlari[:-1] * 100
print(f"GÃ¼nlÃ¼k getiri oranlarÄ± (%): {getiri_oranlari}")

# Ortalama getiri ve volatilite (risk)
ortalama_getiri = np.mean(getiri_oranlari)
volatilite = np.std(getiri_oranlari)
print(f"Ortalama gÃ¼nlÃ¼k getiri: %{ortalama_getiri:.2f}")
print(f"GÃ¼nlÃ¼k volatilite: %{volatilite:.2f}")

"""
AÃ‡IKLAMALAR:
- np.array(): Python listesini NumPy dizisine Ã§evirir
- dtype: Verilerin float64 olmasÄ± ondalÄ±klÄ± fiyatlar iÃ§in ideal
- shape: (10,) 10 elemanlÄ± tek boyutlu dizi olduÄŸunu gÃ¶sterir
- [1:] ve [:-1]: Diziyi kaydÄ±rarak gÃ¼nlÃ¼k farklarÄ± hesaplar
- np.mean() ve np.std(): Ä°statistiksel hesaplamalar iÃ§in kullanÄ±lÄ±r
"""

"""# sÄ±caklÄ±k verisi iÅŸleme"""

import numpy as np

# GerÃ§ek hayat senaryosu: Bir haftalÄ±k sÄ±caklÄ±k Ã¶lÃ§Ã¼mlerini iÅŸleme
print("\n=== Ã–RNEK 2: SÄ±caklÄ±k Verisi Ä°ÅŸleme ===")

# 7 gÃ¼nlÃ¼k ortalama sÄ±caklÄ±k verisi (Â°C)
sicaklik_verisi = [22.5, 24.3, 19.8, 21.2, 26.7, 28.1, 23.4]
sicaklik_dizisi = np.array(sicaklik_verisi)

print(f"7 gÃ¼nlÃ¼k sÄ±caklÄ±k verisi: {sicaklik_dizisi}")

# HaftalÄ±k sÄ±caklÄ±k istatistikleri
max_sicaklik = np.max(sicaklik_dizisi)
min_sicaklik = np.min(sicaklik_dizisi)
ortalama_sicaklik = np.mean(sicaklik_dizisi)

print(f"En yÃ¼ksek sÄ±caklÄ±k: {max_sicaklik}Â°C")
print(f"En dÃ¼ÅŸÃ¼k sÄ±caklÄ±k: {min_sicaklik}Â°C")
print(f"Ortalama sÄ±caklÄ±k: {ortalama_sicaklik:.1f}Â°C")

# SÄ±caklÄ±k sÄ±nÄ±flandÄ±rmasÄ±
sinif_esikleri = [0, 15, 25, 35, 50]  # SoÄŸuk, IlÄ±k, SÄ±cak, Ã‡ok sÄ±cak
sinif_etiketleri = ['SoÄŸuk', 'IlÄ±k', 'SÄ±cak', 'Ã‡ok SÄ±cak']

for i, sicaklik in enumerate(sicaklik_dizisi):
    for j, esik in enumerate(sinif_esikleri[:-1]):
        if esik <= sicaklik < sinif_esikleri[j+1]:
            print(f"GÃ¼n {i+1}: {sicaklik}Â°C â†’ {sinif_etiketleri[j]}")
            break

"""
AÃ‡IKLAMALAR:
- np.max() ve np.min(): Dizideki maksimum ve minimum deÄŸerleri bulur
- np.mean(): Ortalama hesaplar
- enumerate(): Hem indeksi hem deÄŸeri almak iÃ§in kullanÄ±lÄ±r
- SÄ±nÄ±flandÄ±rma: GerÃ§ek hayatta hava durumu analizlerinde kullanÄ±lÄ±r
"""

"""# Ã¶ÄŸrenci notlarÄ± ve istatistik"""

import numpy as np

# GerÃ§ek hayat senaryosu: Bir sÄ±nÄ±fÄ±n sÄ±nav notlarÄ±nÄ± analiz etme
print("\n=== Ã–RNEK 3: Ã–ÄŸrenci NotlarÄ± Analizi ===")

# 20 Ã¶ÄŸrencinin matematik sÄ±nav notlarÄ± (0-100 arasÄ±)
ogrenci_notlari = np.array([85, 92, 78, 65, 45, 88, 95, 72, 58, 81,
                            67, 90, 76, 53, 49, 87, 94, 79, 62, 84])

print(f"Ã–ÄŸrenci notlarÄ±: {ogrenci_notlari}")

# Temel istatistikler
ortalama = np.mean(ogrenci_notlari)
medyan = np.median(ogrenci_notlari)
standart_sapma = np.std(ogrenci_notlari)

print(f"SÄ±nÄ±f ortalamasÄ±: {ortalama:.1f}")
print(f"Medyan: {medyan}")
print(f"Standart sapma: {standart_sapma:.1f}")

# Not daÄŸÄ±lÄ±mÄ± analizi
gecme_notu = 60
gecen_ogrenci_sayisi = np.sum(ogrenci_notlari >= gecme_notu)
kalan_ogrenci_sayisi = np.sum(ogrenci_notlari < gecme_notu)

print(f"GeÃ§en Ã¶ÄŸrenci sayÄ±sÄ±: {gecen_ogrenci_sayisi}")
print(f"Kalan Ã¶ÄŸrenci sayÄ±sÄ±: {kalan_ogrenci_sayisi}")
print(f"BaÅŸarÄ± oranÄ±: %{(gecen_ogrenci_sayisi / len(ogrenci_notlari)) * 100:.1f}")

"""
AÃ‡IKLAMALAR:
- np.median(): Ortanca deÄŸeri bulur (aykÄ±rÄ± deÄŸerlere daha dayanÄ±klÄ±)
- np.sum() + boolean indexing: KoÅŸulu saÄŸlayan elemanlarÄ± sayar
- >= ve < operatÃ¶rleri: NumPy'da element-wise Ã§alÄ±ÅŸÄ±r (her eleman iÃ§in ayrÄ± deÄŸerlendirir)
"""

import numpy as np

# GerÃ§ek hayat senaryosu: 5 maÄŸazanÄ±n aylÄ±k satÄ±ÅŸ verileri
print("\n=== Ã–RNEK 4: MaÄŸaza SatÄ±ÅŸ Analizi ===")

# 5 maÄŸazanÄ±n 3 aylÄ±k satÄ±ÅŸ verileri (bin TL)
satis_verisi = [
    [120, 150, 180],  # MaÄŸaza 1
    [90, 110, 130],   # MaÄŸaza 2
    [200, 220, 240],  # MaÄŸaza 3
    [80, 95, 110],    # MaÄŸaza 4
    [160, 170, 190]   # MaÄŸaza 5
]

satis_dizisi = np.array(satis_verisi)
print(f"SatÄ±ÅŸ verisi (5 maÄŸaza x 3 ay):\n{satis_dizisi}")

# Toplam satÄ±ÅŸlar
aylik_toplam = np.sum(satis_dizisi, axis=0)  # SÃ¼tunlar boyunca toplam
magaza_toplam = np.sum(satis_dizisi, axis=1)  # SatÄ±rlar boyunca toplam
genel_toplam = np.sum(satis_dizisi)

print(f"AylÄ±k toplam satÄ±ÅŸlar: {aylik_toplam} bin TL")
print(f"MaÄŸaza toplam satÄ±ÅŸlarÄ±: {magaza_toplam} bin TL")
print(f"Genel toplam satÄ±ÅŸ: {genel_toplam} bin TL")

# BÃ¼yÃ¼me oranlarÄ±
ilk_ay = satis_dizisi[:, 0]  # TÃ¼m maÄŸazalarÄ±n ilk ay satÄ±ÅŸlarÄ±
son_ay = satis_dizisi[:, 2]  # TÃ¼m maÄŸazalarÄ±n son ay satÄ±ÅŸlarÄ±
buyume_orani = (son_ay - ilk_ay) / ilk_ay * 100

print(f"MaÄŸaza bÃ¼yÃ¼me oranlarÄ± (%): {buyume_orani}")

"""
AÃ‡IKLAMALAR:
- axis=0: SÃ¼tunlar boyunca iÅŸlem (her ayÄ±n toplamÄ±)
- axis=1: SatÄ±rlar boyunca iÅŸlem (her maÄŸazanÄ±n toplamÄ±)
- [:, 0]: TÃ¼m satÄ±rlar, 0. sÃ¼tun - ilk ay satÄ±ÅŸlarÄ±
- [:, 2]: TÃ¼m satÄ±rlar, 2. sÃ¼tun - son ay satÄ±ÅŸlarÄ±
- Broadcasting: Ä°ki dizi arasÄ±nda otomatik boyut uyumlama
"""

import numpy as np

# GerÃ§ek hayat senaryosu: Market Ã¼rÃ¼n stok takibi
print("\n=== Ã–RNEK 5: ÃœrÃ¼n Stok Takibi ===")

# 4 farklÄ± Ã¼rÃ¼nÃ¼n 5 farklÄ± ÅŸubedeki stok miktarlarÄ±
stok_verisi = [
    [50, 30, 25, 40, 35],  # ÃœrÃ¼n A
    [20, 15, 10, 25, 18],  # ÃœrÃ¼n B
    [100, 80, 60, 90, 70], # ÃœrÃ¼n C
    [35, 28, 22, 30, 26]   # ÃœrÃ¼n D
]

stok_dizisi = np.array(stok_verisi)
print(f"Stok verisi (4 Ã¼rÃ¼n x 5 ÅŸube):\n{stok_dizisi}")

# Stok alarmÄ±: Minimum stok seviyesi 20
min_stok_seviyesi = 20
dusuk_stoklar = stok_dizisi < min_stok_seviyesi

print(f"DÃ¼ÅŸÃ¼k stok alarm matrisi:\n{dusuk_stoklar}")

# Hangi Ã¼rÃ¼n-ÅŸube kombinasyonlarÄ±nda stok alarmÄ± var?
alarm_pozisyonlari = np.where(dusuk_stoklar)
print(f"Alarm pozisyonlarÄ±: {list(zip(alarm_pozisyonlari[0], alarm_pozisyonlari[1]))}")

# Toplam stok maliyeti (Ã¼rÃ¼n baÅŸÄ±na birim fiyat)
birim_fiyatlar = np.array([15.50, 8.75, 4.25, 12.30])  # TL
toplam_stok_maliyeti = np.sum(stok_dizisi * birim_fiyatlar[:, np.newaxis])

print(f"Birim fiyatlar: {birim_fiyatlar} TL")
print(f"Toplam stok maliyeti: {toplam_stok_maliyeti:.2f} TL")

"""
AÃ‡IKLAMALAR:
- < operatÃ¶rÃ¼: Element-wise karÅŸÄ±laÅŸtÄ±rma (her eleman iÃ§in True/False)
- np.where(): KoÅŸulu saÄŸlayan elemanlarÄ±n indekslerini dÃ¶ndÃ¼rÃ¼r
- birim_fiyatlar[:, np.newaxis]: (4,) â†’ (4,1) boyutuna Ã§evirir (broadcasting iÃ§in)
- * operatÃ¶rÃ¼: Element-wise Ã§arpÄ±m (her stok miktarÄ± Ã— birim fiyat)
"""

import numpy as np

# GerÃ§ek hayat senaryosu: Fitness uygulamasÄ± adÄ±m verisi
print("\n=== Ã–RNEK 6: Fitness Takip Analizi ===")

# 4 haftalÄ±k gÃ¼nlÃ¼k adÄ±m sayÄ±larÄ±
gunluk_adimlar = np.array([
    [8523, 9234, 7845, 9567, 10234, 11245, 9876],   # Hafta 1
    [9123, 8456, 9234, 8765, 9543, 10345, 8987],    # Hafta 2
    [7654, 8234, 8945, 9345, 8765, 9678, 10234],    # Hafta 3
    [9234, 8567, 9123, 9456, 9876, 10567, 9234]     # Hafta 4
])

print(f"4 haftalÄ±k adÄ±m verisi:\n{gunluk_adimlar}")

# HaftalÄ±k ortalama adÄ±mlar
haftalik_ortalama = np.mean(gunluk_adimlar, axis=1)
print(f"HaftalÄ±k ortalama adÄ±mlar: {haftalik_ortalama.astype(int)}")

# GÃ¼nlÃ¼k hedef: 10,000 adÄ±m
hedef_adim = 10000
hedef_tutan_gunler = gunluk_adimlar >= hedef_adim
hedef_orani = np.mean(hedef_tutan_gunler) * 100

print(f"Hedefi tutan gÃ¼nler:\n{hedef_tutan_gunler}")
print(f"Hedef tutma oranÄ±: %{hedef_orani:.1f}")

# En aktif gÃ¼nler (hafta sonlarÄ±: 5. ve 6. indeksler)
hafta_sonu_adimlari = gunluk_adimlar[:, [5, 6]]  # Cumartesi ve Pazar
hafta_ici_adimlari = gunluk_adimlar[:, :5]       # Pazartesi-Cuma

ortalama_hafta_sonu = np.mean(hafta_sonu_adimlari)
ortalama_hafta_ici = np.mean(hafta_ici_adimlari)

print(f"Ortalama hafta sonu adÄ±mÄ±: {ortalama_hafta_sonu:.0f}")
print(f"Ortalama hafta iÃ§i adÄ±mÄ±: {ortalama_hafta_ici:.0f}")

"""
AÃ‡IKLAMALAR:
- axis=1: SatÄ±rlar boyunca ortalama (her haftanÄ±n ortalamasÄ±)
- astype(int): OndalÄ±klÄ± sayÄ±larÄ± tam sayÄ±ya Ã§evirir
- [:, [5,6]]: TÃ¼m satÄ±rlar, 5. ve 6. sÃ¼tunlar (hafta sonlarÄ±)
- [:, :5]: TÃ¼m satÄ±rlar, ilk 5 sÃ¼tun (hafta iÃ§i)
- Boolean dizilerde np.mean(): True=1, False=0 olarak hesaplar
"""

import numpy as np

# GerÃ§ek hayat senaryosu: AylÄ±k elektrik tÃ¼ketim analizi
print("\n=== Ã–RNEK 7: Enerji TÃ¼ketim Analizi ===")

# 12 aylÄ±k elektrik tÃ¼ketimi (kWh)
aylik_tuketim = np.array([450, 420, 380, 350, 320, 300,
                         350, 380, 400, 430, 460, 480])

print(f"AylÄ±k tÃ¼ketim (kWh): {aylik_tuketim}")

# Mevsimsel analiz
kis_tuketim = aylik_tuketim[[0, 1, 10, 11]]  # Ocak, Åubat, KasÄ±m, AralÄ±k
yaz_tuketim = aylik_tuketim[5:8]             # Haziran, Temmuz, AÄŸustos

ortalama_kis = np.mean(kis_tuketim)
ortalama_yaz = np.mean(yaz_tuketim)

print(f"KÄ±ÅŸ aylarÄ± tÃ¼ketimi: {kis_tuketim}")
print(f"Yaz aylarÄ± tÃ¼ketimi: {yaz_tuketim}")
print(f"Ortalama kÄ±ÅŸ tÃ¼ketimi: {ortalama_kis:.1f} kWh")
print(f"Ortalama yaz tÃ¼ketimi: {ortalama_yaz:.1f} kWh")

# TÃ¼ketim trend analizi
aylik_degisim = (aylik_tuketim[1:] - aylik_tuketim[:-1]) / aylik_tuketim[:-1] * 100
print(f"AylÄ±k deÄŸiÅŸim oranlarÄ± (%): {aylik_degisim}")

# AnomalÄ± tÃ¼ketim tespiti (ortalama Â± 2 standart sapma)
ortalama = np.mean(aylik_tuketim)
std_sapma = np.std(aylik_tuketim)
ust_sinir = ortalama + 2 * std_sapma
alt_sinir = ortalama - 2 * std_sapma

anomaliler = (aylik_tuketim > ust_sinir) | (aylik_tuketim < alt_sinir)
print(f"AnomalÄ± aylar: {np.where(anomaliler)[0] + 1}")  # +1 Ã§Ã¼nkÃ¼ aylar 1'den baÅŸlar

"""
AÃ‡IKLAMALAR:
- [0, 1, 10, 11]: Fancy indexing - belirli indeksleri seÃ§er
- 5:8: Dilimleme - 5, 6, 7. indeksleri seÃ§er (8 dahil deÄŸil)
- | operatÃ¶rÃ¼: Boolean OR iÅŸlemi
- np.where()[0]: KoÅŸulu saÄŸlayan indeksleri dÃ¶ndÃ¼rÃ¼r
"""

import numpy as np

# GerÃ§ek hayat senaryosu: MÃ¼ÅŸteri harcama alÄ±ÅŸkanlÄ±klarÄ± analizi
print("\n=== Ã–RNEK 8: MÃ¼ÅŸteri Segmentasyonu ===")

# 8 mÃ¼ÅŸterinin 3 aylÄ±k harcama verileri (TL)
musteri_harcamalari = np.array([
    [1200, 1500, 1800],  # MÃ¼ÅŸteri 1
    [800, 950, 1100],    # MÃ¼ÅŸteri 2
    [2500, 2800, 3000],  # MÃ¼ÅŸteri 3
    [600, 700, 850],     # MÃ¼ÅŸteri 4
    [1800, 2000, 2200],  # MÃ¼ÅŸteri 5
    [950, 1200, 1400],   # MÃ¼ÅŸteri 6
    [3000, 3200, 3500],  # MÃ¼ÅŸteri 7
    [750, 800, 900]      # MÃ¼ÅŸteri 8
])

print(f"MÃ¼ÅŸteri harcama verisi:\n{musteri_harcamalari}")

# Boolean indexing ile mÃ¼ÅŸteri segmentasyonu
vip_esik = 2500  # VIP mÃ¼ÅŸteri eÅŸiÄŸi
vip_musteriler = musteri_harcamalari[:, -1] > vip_esik  # Son ay harcamasÄ±
print(f"VIP mÃ¼ÅŸteri maskesi: {vip_musteriler}")

# VIP mÃ¼ÅŸterilerin verilerini seÃ§
vip_verisi = musteri_harcamalari[vip_musteriler]
print(f"VIP mÃ¼ÅŸteri verisi:\n{vip_verisi}")

# BÃ¼yÃ¼me potansiyeli olan mÃ¼ÅŸteriler (her ay artan harcama)
artis_musteriler = np.all(musteri_harcamalari[:, 1:] > musteri_harcamalari[:, :-1], axis=1)
print(f"BÃ¼yÃ¼me mÃ¼ÅŸterileri: {artis_musteriler}")

# TÃ¼m segmentleri birleÅŸtir
segmentler = np.zeros(len(musteri_harcamalari), dtype='<U10')  # String dizi
segmentler[vip_musteriler] = 'VIP'
segmentler[artis_musteriler & ~vip_musteriler] = 'BÃ¼yÃ¼yor'
segmentler[~(vip_musteriler | artis_musteriler)] = 'Standart'

print(f"MÃ¼ÅŸteri segmentleri: {segmentler}")

"""
AÃ‡IKLAMALAR:
- [:, -1]: TÃ¼m mÃ¼ÅŸterilerin son ay harcamalarÄ±
- [vip_musteriler]: Boolean indexing - True olan satÄ±rlarÄ± seÃ§er
- np.all(axis=1): SatÄ±r bazÄ±nda tÃ¼m koÅŸullarÄ±n True olup olmadÄ±ÄŸÄ±nÄ± kontrol eder
- & ve |: Boolean AND/OR operatÃ¶rleri
- ~: Boolean NOT operatÃ¶rÃ¼
- dtype='<U10': Maksimum 10 karakterli Unicode string
"""

import numpy as np

# GerÃ§ek hayat senaryosu: E-ticaret Ã¼rÃ¼n Ã¶zellik analizi
print("\n=== Ã–RNEK 9: ÃœrÃ¼n Ã–zellik Matrisi Ä°ÅŸleme ===")

# 6 Ã¼rÃ¼nÃ¼n 4 Ã¶zelliÄŸi (fiyat, deÄŸerlendirme, stok, aÄŸÄ±rlÄ±k)
urun_ozellikleri = np.array([
    [299.99, 4.5, 50, 1.2],   # ÃœrÃ¼n A
    [149.50, 4.2, 25, 0.8],   # ÃœrÃ¼n B
    [599.99, 4.8, 10, 3.5],   # ÃœrÃ¼n C
    [79.99, 3.9, 100, 0.5],   # ÃœrÃ¼n D
    [399.99, 4.6, 15, 2.1],   # ÃœrÃ¼n E
    [199.99, 4.0, 40, 1.5]    # ÃœrÃ¼n F
])

print(f"ÃœrÃ¼n Ã¶zellik matrisi:\n{urun_ozellikleri}")

# Fancy indexing ile belirli Ã¼rÃ¼nleri seÃ§
populer_urunler = [0, 2, 4]  # En popÃ¼ler Ã¼rÃ¼nlerin indeksleri
populer_verisi = urun_ozellikleri[populer_urunler]
print(f"PopÃ¼ler Ã¼rÃ¼nler:\n{populer_verisi}")

# Belirli Ã¶zelliklere gÃ¶re sÄ±ralama (deÄŸerlendirmeye gÃ¶re azalan)
siralama_indeksleri = np.argsort(urun_ozellikleri[:, 1])[::-1]  # DeÄŸerlendirme sÃ¼tunu
siralanmis_urunler = urun_ozellikleri[siralama_indeksleri]

print(f"DeÄŸerlendirmeye gÃ¶re sÄ±ralanmÄ±ÅŸ Ã¼rÃ¼nler:\n{siralanmis_urunler}")

# Ã‡oklu koÅŸullu filtreleme (fiyat < 300 ve deÄŸerlendirme > 4.0)
uygun_urunler = (urun_ozellikleri[:, 0] < 300) & (urun_ozellikleri[:, 1] > 4.0)
secilen_urunler = urun_ozellikleri[uygun_urunler]

print(f"Uygun Ã¼rÃ¼nler (fiyat < 300, deÄŸerlendirme > 4.0):\n{secilen_urunler}")

"""
AÃ‡IKLAMALAR:
- [populer_urunler]: Fancy indexing - belirli satÄ±rlarÄ± seÃ§er
- np.argsort(): SÄ±ralanmÄ±ÅŸ indeksleri dÃ¶ndÃ¼rÃ¼r
- [::-1]: Diziyi ters Ã§evirir (azalan sÄ±ra iÃ§in)
- [:, 0] ve [:, 1]: Belirli sÃ¼tunlarÄ± seÃ§er
- Ã‡oklu koÅŸullar: Parantezler Ã¶nemli!
"""

import numpy as np

# GerÃ§ek hayat senaryosu: SensÃ¶r verisini yeniden yapÄ±landÄ±rma
print("\n=== Ã–RNEK 10: Zaman Serisi Yeniden Åekillendirme ===")

# 30 gÃ¼nlÃ¼k gÃ¼nlÃ¼k sÄ±caklÄ±k Ã¶lÃ§Ã¼mleri (dÃ¼z liste)
duz_veri = np.array([
    22.5, 23.1, 21.8, 24.2, 25.6, 26.8, 27.3, 26.5, 25.2, 23.8,
    22.1, 21.5, 20.8, 22.3, 24.7, 26.1, 27.8, 28.2, 27.5, 26.3,
    24.9, 23.4, 22.7, 21.9, 23.2, 25.4, 26.9, 28.1, 29.3, 28.7
])

print(f"DÃ¼z veri boyutu: {duz_veri.shape}")

# Veriyi haftalÄ±k formata Ã§evir (4 hafta x 7 gÃ¼n)
haftalik_veri = duz_veri.reshape(4, 7)
print(f"HaftalÄ±k veri (4 hafta x 7 gÃ¼n):\n{haftalik_veri}")

# Hafta sonu ve hafta iÃ§i analizi
hafta_sonu_verisi = haftalik_veri[:, [5, 6]]  # Cumartesi ve Pazar
hafta_ici_verisi = haftalik_veri[:, :5]       # Pazartesi-Cuma

print(f"Hafta sonu verisi:\n{hafta_sonu_verisi}")
print(f"Hafta iÃ§i verisi:\n{hafta_ici_verisi}")

# Transpoz: GÃ¼nler satÄ±r, haftalar sÃ¼tun olacak ÅŸekilde
transpoz_veri = haftalik_veri.T
print(f"Transpoz veri (7 gÃ¼n x 4 hafta):\n{transpoz_veri}")

# Belirli bir haftanÄ±n verisini seÃ§ ve iÅŸle
ikinci_hafta = haftalik_veri[1, :]  # 2. haftanÄ±n tÃ¼m gÃ¼nleri
print(f"2. hafta verisi: {ikinci_hafta}")

# VIEW vs COPY Ã¶rneÄŸi
view_veri = haftalik_veri[0:2, :]    # VIEW - orijinal veriyi paylaÅŸÄ±r
copy_veri = haftalik_veri[0:2, :].copy()  # COPY - yeni bellek alanÄ±

print(f"View base: {view_veri.base is haftalik_veri}")  # True
print(f"Copy base: {copy_veri.base is haftalik_veri}")  # False

"""
AÃ‡IKLAMALAR:
- reshape(4, 7): 30 elemanlÄ± diziyi 4x7 matrise Ã§evirir
- [:, [5,6]]: TÃ¼m satÄ±rlar, 5. ve 6. sÃ¼tunlar
- .T: Transpoz iÅŸlemi (satÄ±râ†”sÃ¼tun)
- [1, :]: 1. satÄ±rÄ±n tÃ¼m sÃ¼tunlarÄ±
- .base: Dizinin view mi copy mi olduÄŸunu kontrol eder
"""

import numpy as np

# GerÃ§ek hayat senaryosu: 3 boyutlu depo stok takibi
print("\n=== Ã–RNEK 11: Ã‡ok Boyutlu Stok Takip Sistemi ===")

# 3 depo x 4 raf x 6 bÃ¶lÃ¼m stok verisi
depo_stoklari = np.random.randint(0, 100, size=(3, 4, 6))
print(f"Depo stok verisi boyutu: {depo_stoklari.shape}")
print(f"Depo 0 stoklarÄ±:\n{depo_stoklari[0]}")

# Belirli bir deponun tÃ¼m stoklarÄ±nÄ± seÃ§
depo_1_stok = depo_stoklari[1, :, :]  # 1. deponun tÃ¼m raf ve bÃ¶lÃ¼mleri
print(f"Depo 1 stoklarÄ±:\n{depo_1_stok}")

# TÃ¼m depolarÄ±n belirli bir rafÄ±ndaki stoklar
raf_2_stok = depo_stoklari[:, 2, :]  # TÃ¼m depolarÄ±n 2. rafÄ±
print(f"Raf 2 stoklarÄ± (tÃ¼m depolar):\n{raf_2_stok}")

# Ã‡oklu indeksleme ile karmaÅŸÄ±k seÃ§im
ozel_secim = depo_stoklari[[0, 2], 1:3, [2, 4, 5]]
print(f"Ã–zel seÃ§im (depo 0,2; raf 1,2; bÃ¶lÃ¼m 2,4,5):\n{ozel_secim}")

# Stok azlÄ±ÄŸÄ± tespiti
dusuk_stok_esigi = 20
dusuk_stoklar = depo_stoklari < dusuk_stok_esigi
dusuk_stok_sayisi = np.sum(dusuk_stoklar)

print(f"DÃ¼ÅŸÃ¼k stok sayÄ±sÄ±: {dusuk_stok_sayisi}")
print(f"DÃ¼ÅŸÃ¼k stok pozisyonlarÄ±: {np.where(dusuk_stoklar)}")

"""
AÃ‡IKLAMALAR:
- (3, 4, 6): 3 depo, her depoda 4 raf, her rafta 6 bÃ¶lÃ¼m
- [1, :, :]: 1. depo, tÃ¼m raflar, tÃ¼m bÃ¶lÃ¼mler
- [:, 2, :]: TÃ¼m depolar, 2. raf, tÃ¼m bÃ¶lÃ¼mler
- [[0,2], 1:3, [2,4,5]]: Fancy indexing + dilimleme kombinasyonu
- np.where(): Ã‡ok boyutlu dizilerde koordinatlarÄ± dÃ¶ndÃ¼rÃ¼r
"""

import numpy as np

# GerÃ§ek hayat senaryosu: Ã‡alÄ±ÅŸan maaÅŸ bordrosu hesaplama
print("\n=== Ã–RNEK 12: MaaÅŸ Bordro Hesaplama Sistemi ===")

# 8 Ã§alÄ±ÅŸanÄ±n temel maaÅŸ, prim, mesai verileri
calisan_verisi = np.array([
    [8500, 1200, 15],   # Ã‡alÄ±ÅŸan 1
    [7200, 800, 8],     # Ã‡alÄ±ÅŸan 2
    [9500, 1500, 20],   # Ã‡alÄ±ÅŸan 3
    [6800, 600, 5],     # Ã‡alÄ±ÅŸan 4
    [7800, 1000, 12],   # Ã‡alÄ±ÅŸan 5
    [9200, 1300, 18],   # Ã‡alÄ±ÅŸan 6
    [7500, 900, 10],    # Ã‡alÄ±ÅŸan 7
    [8800, 1100, 14]    # Ã‡alÄ±ÅŸan 8
])

print(f"Ã‡alÄ±ÅŸan verisi (temel maaÅŸ, prim, mesai saati):\n{calisan_verisi}")

# Net maaÅŸ hesaplama (temel + prim + mesai*50 - vergi)
mesai_ucreti = 50
vergi_orani = 0.15

temel_maas = calisan_verisi[:, 0]
prim = calisan_verisi[:, 1]
mesai_saati = calisan_verisi[:, 2]

brut_maas = temel_maas + prim + (mesai_saati * mesai_ucreti)
vergi = brut_maas * vergi_orani
net_maas = brut_maas - vergi

print(f"BrÃ¼t maaÅŸlar: {brut_maas}")
print(f"Vergiler: {vergi}")
print(f"Net maaÅŸlar: {net_maas}")

# MaaÅŸ bandÄ± analizi
maas_bandlari = [0, 8000, 10000, 15000, np.inf]
band_etiketleri = ['DÃ¼ÅŸÃ¼k', 'Orta', 'YÃ¼ksek', 'Ã‡ok YÃ¼ksek']

for i, maas in enumerate(brut_maas):
    for j in range(len(maas_bandlari)-1):
        if maas_bandlari[j] <= maas < maas_bandlari[j+1]:
            print(f"Ã‡alÄ±ÅŸan {i+1}: {maas:.0f} TL â†’ {band_etiketleri[j]} band")
            break

"""
AÃ‡IKLAMALAR:
- [:, 0], [:, 1], [:, 2]: SÃ¼tun bazlÄ± veri seÃ§imi
- Element-wise operasyonlar: TÃ¼m diziler aynÄ± anda iÅŸlenir
- np.inf: Sonsuzluk, Ã¼st sÄ±nÄ±r iÃ§in kullanÄ±lÄ±r
- enumerate(): Hem indeks hem deÄŸer iÃ§in kullanÄ±ÅŸlÄ±
"""

import numpy as np

# GerÃ§ek hayat senaryosu: Ãœretim hattÄ± kalite kontrolÃ¼
print("\n=== Ã–RNEK 13: Kalite Kontrol Veri Analizi ===")

# 5 makinenin 10 gÃ¼nlÃ¼k hata sayÄ±larÄ±
hata_verisi = np.array([
    [2, 1, 0, 3, 2, 1, 0, 2, 1, 2],  # Makine 1
    [5, 4, 6, 3, 5, 4, 5, 6, 4, 5],  # Makine 2
    [1, 0, 1, 2, 0, 1, 1, 0, 2, 1],  # Makine 3
    [3, 2, 4, 3, 2, 3, 4, 3, 2, 3],  # Makine 4
    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]   # Makine 5
])

print(f"Hata verisi (5 makine x 10 gÃ¼n):\n{hata_verisi}")

# Boolean indexing ile problemli gÃ¼nleri bul
kritik_esik = 4
problemli_gunler = hata_verisi > kritik_esik
print(f"Problemli gÃ¼nler (hata > {kritik_esik}):\n{problemli_gunler}")

# Her makinenin problemli gÃ¼n sayÄ±sÄ±
makine_problem_sayisi = np.sum(problemli_gunler, axis=1)
print(f"Makine problem sayÄ±larÄ±: {makine_problem_sayisi}")

# En problemli makineyi bul
en_problemli_makine = np.argmax(makine_problem_sayisi)
print(f"En problemli makine: {en_problemli_makine + 1}")

# Hareketli ortalama ile trend analizi (3 gÃ¼nlÃ¼k)
def hareketli_ortalama(dizi, pencere):
    return np.convolve(dizi, np.ones(pencere)/pencere, mode='valid')

makine_2_trend = hareketli_ortalama(hata_verisi[1], 3)
print(f"Makine 2 hareketli ortalama (3 gÃ¼n): {makine_2_trend}")

"""
AÃ‡IKLAMALAR:
- > operatÃ¶rÃ¼: Element-wise bÃ¼yÃ¼ktÃ¼r karÅŸÄ±laÅŸtÄ±rmasÄ±
- np.sum(axis=1): SatÄ±rlar boyunca toplam (her makinenin problem sayÄ±sÄ±)
- np.argmax(): Maksimum deÄŸerin indeksini dÃ¶ndÃ¼rÃ¼r
- np.convolve(): KonvolÃ¼syon ile hareketli ortalama hesaplar
- mode='valid': Kenar efektleri olmadan geÃ§erli pencereler
"""

import numpy as np

# GerÃ§ek hayat senaryosu: MÃ¼ÅŸteri memnuniyet anketi analizi
print("\n=== Ã–RNEK 14: MÃ¼ÅŸteri Memnuniyet Anketi ===")

# 20 mÃ¼ÅŸterinin 5 soruya verdiÄŸi puanlar (1-5 arasÄ±)
anket_verisi = np.array([
    [5, 4, 3, 5, 4], [4, 3, 4, 4, 3], [5, 5, 5, 5, 5], [2, 3, 2, 3, 2],
    [4, 4, 4, 4, 4], [3, 3, 4, 3, 3], [5, 4, 5, 4, 5], [1, 2, 1, 2, 1],
    [4, 5, 4, 5, 4], [3, 4, 3, 4, 3], [5, 4, 4, 5, 4], [2, 2, 3, 2, 2],
    [4, 4, 5, 4, 4], [3, 3, 3, 3, 3], [5, 5, 4, 5, 5], [4, 3, 4, 3, 4],
    [3, 4, 3, 4, 3], [5, 4, 5, 4, 5], [2, 3, 2, 3, 2], [4, 4, 4, 4, 4]
])

print(f"Anket verisi (20 mÃ¼ÅŸteri x 5 soru):\n{anket_verisi}")

# Soru bazÄ±nda ortalama puanlar
soru_ortalamalari = np.mean(anket_verisi, axis=0)
print(f"Soru ortalamalarÄ±: {soru_ortalamalari}")

# MÃ¼ÅŸteri bazÄ±nda toplam puanlar
musteri_toplamlari = np.sum(anket_verisi, axis=1)
print(f"MÃ¼ÅŸteri toplam puanlarÄ±: {musteri_toplamlari}")

# Memnun mÃ¼ÅŸterileri belirle (toplam puan >= 20)
memnun_musteriler = musteri_toplamlari >= 20
memnun_orani = np.mean(memnun_musteriler) * 100

print(f"Memnun mÃ¼ÅŸteri sayÄ±sÄ±: {np.sum(memnun_musteriler)}")
print(f"Memnuniyet oranÄ±: %{memnun_orani:.1f}")

# En dÃ¼ÅŸÃ¼k puan alan soruyu bul
en_kotu_soru = np.argmin(soru_ortalamalari)
print(f"En dÃ¼ÅŸÃ¼k puan alan soru: {en_kotu_soru + 1} (ortalama: {soru_ortalamalari[en_kotu_soru]:.2f})")

"""
AÃ‡IKLAMALAR:
- axis=0: SÃ¼tunlar boyunca ortalama (her sorunun ortalamasÄ±)
- axis=1: SatÄ±rlar boyunca toplam (her mÃ¼ÅŸterinin toplam puanÄ±)
- >= operatÃ¶rÃ¼: Boolean dizi oluÅŸturur
- np.argmin(): Minimum deÄŸerin indeksini dÃ¶ndÃ¼rÃ¼r
- Boolean dizide np.mean(): True oranÄ±nÄ± hesaplar
"""

import numpy as np

# GerÃ§ek hayat senaryosu: PortfÃ¶y risk analizi
print("\n=== Ã–RNEK 15: Finansal Risk Analizi ===")

# 5 farklÄ± hisse senedinin 30 gÃ¼nlÃ¼k getiri oranlarÄ± (%)
getiri_verisi = np.random.normal(0.1, 2, size=(5, 30))  # Ortalama %0.1, std %2
print(f"Getiri verisi (5 hisse x 30 gÃ¼n):\n{getiri_verisi}")

# Her hissenin ortalama getirisi ve volatilitesi
hisse_ortalamalari = np.mean(getiri_verisi, axis=1)
hisse_volatiliteleri = np.std(getiri_verisi, axis=1)

print(f"Hisse ortalamalarÄ± (%): {hisse_ortalamalari}")
print(f"Hisse volatiliteleri (%): {hisse_volatiliteleri}")

# Risk-getiri analizi: Sharpe OranÄ± (risk-free rate = %0.05)
risk_free_rate = 0.05
sharpe_oranlari = (hisse_ortalamalari - risk_free_rate) / hisse_volatiliteleri

print(f"Sharpe oranlarÄ±: {sharpe_oranlari}")

# En iyi performans gÃ¶steren hisseyi bul
en_iyi_hisse = np.argmax(sharpe_oranlari)
print(f"En iyi performans gÃ¶steren hisse: {en_iyi_hisse + 1}")

# Korelasyon matrisi
korelasyon_matrisi = np.corrcoef(getiri_verisi)
print(f"Korelasyon matrisi:\n{korelasyon_matrisi}")

# YÃ¼ksek korelasyonlu hisse Ã§iftlerini bul
yuksek_korelasyon_esigi = 0.7
yuksek_korelasyonlar = np.where((korelasyon_matrisi > yuksek_korelasyon_esihi) &
                               (korelasyon_matrisi < 1.0))  # 1.0'dan kÃ¼Ã§Ã¼k (kendisiyle korelasyon deÄŸil)

print(f"YÃ¼ksek korelasyonlu hisse Ã§iftleri: {list(zip(yuksek_korelasyonlar[0], yuksek_korelasyonlar[1]))}")

"""
AÃ‡IKLAMALAR:
- np.random.normal(): Normal daÄŸÄ±lÄ±mdan rastgele sayÄ±lar Ã¼retir
- axis=1: SatÄ±rlar boyunca istatistik (her hissenin istatistiÄŸi)
- Sharpe OranÄ±: Risk birimi baÅŸÄ±na getiriyi Ã¶lÃ§er
- np.corrcoef(): Korelasyon matrisi hesaplar
- np.where() + koÅŸul: Matriste koÅŸulu saÄŸlayan pozisyonlarÄ± bulur
- zip(): Ä°ki listeyi Ã§iftler halinde birleÅŸtirir
"""