# -*- coding: utf-8 -*-
"""oturum2_29_ekim_numpy_dizi_islemleri.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c9-iU84JGAfobOM9YcxrvQUP6eetPW7o

# np.arange ile listeler üretmek
numpy.arange([start,] stop[, step], dtype=None)
"""

import numpy as np

a = np.arange(5)
print(a)

b = np.arange(2, 10)
print(b)

c = np.arange(2, 10, 2)
print(c)

d = np.arange(10, 2, -2)
print(d)

#ondalıklı değerler ile
d = np.arange(0, 1, 0.2)
print(d)

#dtype parametresi ile
# dtype=int / dtype=float / dtype=complex gibi tipler kullanılabilir.
e = np.arange(0, 10, 2, dtype=float)
print(e)

# a) Sayısal aralıklar oluşturmak - Sinyal, grafik veya matematiksel hesaplamalarda sıkça kullanılır.

x = np.arange(0, 2*np.pi, 0.1)
y = np.sin(x)
print(y)

# b) Matris şekline dönüştürmek -

a = np.arange(12).reshape(3, 4)
print(a)

"""| Özellik                  | `arange()`                      | `linspace()`              |
| ------------------------ | ------------------------------- | ------------------------- |
| Adım belirleme           | `step` parametresiyle           | Eleman sayısı (`num`) ile |
| Uç değer (stop) dahil mi | **Hayır**                       | **Evet (varsayılan)**     |
| Ondalık hatası riski     | Evet (floating-point precision) | Hayır (daha kesin)        |

"""

np.arange(0, 1, 0.2)      # [0. , 0.2, 0.4, 0.6, 0.8]
np.linspace(0, 1, 5)       # [0. , 0.25, 0.5 , 0.75, 1. ]

"""# Örnekler"""

#kare alma
x = np.arange(1, 6)
y = x ** 2
print("x:", x)
print("y:", y)

#grafik çizimi

import matplotlib.pyplot as plt

x = np.arange(0, 2*np.pi, 0.1)
y = np.sin(x)

plt.plot(x, y)
plt.title("Sinüs Grafiği")
plt.xlabel("x")
plt.ylabel("sin(x)")
plt.show()

#arange dizi oluşturucu örnek

import numpy as np

def arange_olusturucu():
    print("🔹 NumPy arange() oluşturucuya hoş geldiniz!\n")

    # Kullanıcıdan değerleri al
    start = input("Başlangıç değerini girin (boş bırak = 0): ")
    stop = input("Bitiş değerini girin (zorunlu): ")
    step = input("Adım (step) değerini girin (boş bırak = 1): ")
    dtype = input("Veri tipi girin (int, float, complex veya boş bırak): ")

    # Boş bırakılan alanlar için varsayılan değer atama
    start = float(start) if start.strip() != "" else 0
    step = float(step) if step.strip() != "" else 1

    # stop değeri zorunlu
    if stop.strip() == "":
        print("⚠️ 'stop' değeri zorunludur!")
        return
    stop = float(stop)

    # dtype belirleme
    dtype_map = {"int": int, "float": float, "complex": complex}
    dtype = dtype_map.get(dtype.strip().lower(), None)

    # arange oluştur
    arr = np.arange(start, stop, step, dtype=dtype)

    # Sonuçları yazdır
    print("\n✅ Oluşturulan NumPy dizisi:")
    print(arr)
    print(f"\nDizinin veri tipi: {arr.dtype}")
    print(f"Dizinin boyutu (shape): {arr.shape}")
    print(f"Eleman sayısı: {arr.size}")

# Fonksiyonu çalıştır
arange_olusturucu()

"""# np.random ile diziler oluşturmak

"""

#rastgele diziler oluşturmak için

#random.rand() metodu:
#0-1	arasında verdiğimiz parametre kadar değer üretir.
np.random.rand(5)

np.random.rand(2,3) # 2x3 lük bir matris oluşturur

#random.normal() metodu:
#Ortalaması 0 varyansı 1 olan 3x3 lük matris oluşturmak için,
np.random.normal(0,10,(3,3))
#aşağıdaki gibi de olabilir
np.random.normal(0,10,size=(3,3))

#ortalaması 10 standart sapması 3 olan bir matris oluşturalım.
np.random.normal(10,3,(3,3))

#random.randint() metodu:
#Bu metod ile girilen değerler arasında istenilen sayı kadar rasgele  integer sayı üretmemizi sağlar. 0-10 arasında rasgele bir sayı oluşturmak istersek
np.random.randint(0,10)


#Eğer random fonksiyonunu kullanırken tek parametre verirsek
np.random.randint(10) # Başlangıç değeri 0 verilmiş gibi değer üretir.


# 3 . Bir parametre girilerek kaç tane sayı oluşturabileceğimizi belirleyebiliriz.
np.random.randint(0,10,8) # 8 elemanlı bir vektör(tek boyutlu dizi) oluşturduk.

# 3X3 lük bir matris oluşturmak istersek
np.random.randint(0,10,(3,3))
"""
array([[4, 4, 4],
       [9, 3, 2],
       [0, 0, 5]])
"""
np.random.randint(0,10,size=(3,3))
"""
array([[6, 9, 4],
       [5, 3, 7],
       [5, 4, 3]])
       """
# random.randn() metodu:
#normal dağılımlı rasgele değerlerden oluşan bir array oluşturmak için kullanılır.
np.random.randn(3,4)

"""#Temel ve Gelişmiş İndeksleme Teknikleri

**İndeksleme Nedir? Neden Önemli?**

*   İndeksleme: Dizilerden belirli elemanları seçme işlemidir

*  Önemi: Veri analizinde sadece ilgili verilere odaklanmamızı sağlar

**Türleri:**

* Temel indeksleme (basic indexing)

* Gelişmiş indeksleme (advanced indexing)

* Boolean indeksleme

* Fancy indeksleme

**Temel İndeksleme Kuralları:**

* Python'daki liste indekslemeye benzer ama çok daha güçlü

* `0-tabanlı indeksleme`: İlk eleman indeksi 0'dır

* *Negatif indeksler*: Sondan saymaya yarar (-1 son eleman)

* *Çok boyutlu dizilerde*: dizi[satir, sutun] syntax'ı
"""

import numpy as np

# 1B Dizi İndeksleme
dizi_1b = np.array([10, 20, 30, 40, 50])
print("1B Dizi:", dizi_1b)
print("dizi_1b[0]:", dizi_1b[0])           # İlk eleman
print("dizi_1b[-1]:", dizi_1b[-1])         # Son eleman
print("dizi_1b[2:4]:", dizi_1b[2:4])       # 2. ve 3. eleman (4 dahil değil)
print("dizi_1b[::2]:", dizi_1b[::2])       # Bir atlayarak
print("---")

# 2B Dizi İndeksleme
dizi_2b = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])
print("2B Dizi:\n", dizi_2b)
print("dizi_2b[0, 1]:", dizi_2b[0, 1])     # 0. satır, 1. sütun -> 2
print("dizi_2b[1, -1]:", dizi_2b[1, -1])   # 1. satır, son sütun -> 8
print("---")

# 3B Dizi İndeksleme
dizi_3b = np.array([[[1, 2], [3, 4]],
                    [[5, 6], [7, 8]]])
print("3B Dizi shape:", dizi_3b.shape)     # (2, 2, 2)
print("dizi_3b[0, 1, 0]:", dizi_3b[0, 1, 0]) # 0. matris, 1. satır, 0. sütun -> 3

"""#Tek ve İki Boyutlu Dizilerde Erişim
NumPy'da veri seçimi, Python listelerindeki gibi indeks (konum) numaralarıyla yapılır. 2D dizilerde kural: array[satır, sütun].
"""

import numpy as np

# 2D Dizi Örneği: 3 Aylık Satış Verisi (Satır: Ay, Sütun: Ürün Tipi)
# [A ürünü, B ürünü, C ürünü, D ürünü]
satislar = np.array([
    [100, 150, 75, 200],  # Ocak (Indeks 0)
    [120, 160, 80, 220],  # Şubat (Indeks 1)
    [110, 145, 90, 210]   # Mart (Indeks 2)
])
print("Orijinal Matris (Shape: 3x4):\n", satislar)

# Örnek 1: Tek Eleman Seçimi
# Şubat (indeks 1) ayındaki B ürününün (indeks 1) satışı
subat_urun_b = satislar[1, 1]
print(f"\nŞubat B Ürünü Satışı (1, 1): {subat_urun_b}")
# Çıktı: 160

# Örnek 2: Tüm Sütunu Seçme
# D ürününün (indeks 3) tüm aylar boyunca olan satışlarını çekme
urun_d_tum_aylar = satislar[:, 3] # Tüm satırları al (:) ve sadece 3. sütunu seç
print(f"\nD Ürününün Tüm Aylar Satışı (:, 3): {urun_d_tum_aylar}")
# Çıktı: [200 220 210]

"""**Önemli: NumPy slicing genelde bir view döndürür — kopya değil. Yani slice üzerinde yapılan değişiklik orijinal diziyi değiştirir**"""

c = np.arange(6)
d = c[1:4]
d[:] = 100
print(c)  # [  0 100 100 100  4  5]

"""# Çok boyutlu indeksleme (2-D örnek)

Satır ve sütun belirtme: arr[row, col].
İki ayrı köşeli parantez gerekmez (arr[row][col] de çalışır ama arr[row, col] tercih edilir).
"""

M = np.arange(12).reshape(3,4)
# M =
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

print(M[0, 1])    # 1  (0. satır, 1. sütun)
print(M[1])       # [4 5 6 7] (1. satır tüm sütunlar)
print(M[:, 2])    # [2 6 10] (tüm satırların 2. sütunu) -> 1D array
print(M[0:2, 1:3])# alt-matris [[1,2],[5,6]]

# Örnek 3: Dilimleme (Satır ve Sütun)
# Ocak ve Şubat (indeks 0'dan 2'ye kadar, 2 dahil değil) A ve B ürünleri (indeks 0'dan 2'ye kadar)
ilk_iki_ay_urun_ab = satislar[0:2, 0:2]
print(f"\nOcak-Şubat, A ve B Ürünleri:\n{ilk_iki_ay_urun_ab}")
# Çıktı: [[100 150] [120 160]]

# Örnek 4: Negatif Dilimleme
# En son satırdan (-1) en sona kadar tüm sütunları seç (Mart ayı)
son_ay = satislar[-1, :]
print(f"\nNegatif Dilimleme (Son Ay): {son_ay}")
# Çıktı: [110 145 90 210]

"""#Dilimleme ile görünüm (view) vs kopya (copy)

NumPy'da dilimleme ile (sadece : operatörü kullanılarak) elde edilen alt dizi, orijinal dizinin bellekteki verisine doğrudan erişim sağlayan bir görünüm (view)'dür.


M[0:2, :] → view (varsayılan, bellek paylaşılır).

M[:, 2] → genelde view (ama bazı karmaşık durumlarda kopya olabilir).

Fancy indexing (aşağıda) her zaman kopya döndürür.

Kopya istenirse kopya kullanın: > `sub = M[0:2, :].copy()`

| Özellik | Görünüm (View, Genellikle Dilimleme ile) | Kopya (Copy, Genellikle `.copy()` ile) |
|---------|------------------------------------------|----------------------------------------|
| Bağımlılık | Orijinal diziye bağımlıdır. | Orijinal diziden bağımsızdır. |
| Bellek | Yeni bir bellek alanı kullanmaz (hızlıdır). | Bellekte yeni bir alan tahsis eder (güvenlidir). |
| Risk | Görünümdeki değişiklik, orijinal diziyi bozar. | Orijinal diziye etkisi yoktur. |
"""

# Gerçek Hayat Örneği: Veri Güvenliği
ana_veri = np.array([10, 20, 30, 40, 50])
print(f"Başlangıç: {ana_veri}") # [10 20 30 40 50]

# 1. GÖRÜNÜM (VIEW) Oluşturma (Genellikle Slicing ile)
analiz_view = ana_veri[0:3]

# Görünümdeki ilk elemanı değiştiriyoruz.
analiz_view[0] = 999

# SONUÇ: Orijinal dizi de değişti!
print(f"View sonrası Orijinal: {ana_veri}")
# Çıktı: [999 20 30 40 50]  Orijinal verimiz bozuldu!

# 2. KOPYA (COPY) Oluşturma
ana_veri_safe = np.array([10, 20, 30, 40, 50])
# Güvenli analiz için daima .copy() kullanın.
analiz_copy = ana_veri_safe[0:3].copy()

# Kopyadaki ilk elemanı değiştiriyoruz.
analiz_copy[0] = 888

# SONUÇ: Orijinal dizi GÜVENDE! ✅
print(f"\nCopy sonrası Orijinal: {ana_veri_safe}")
# Çıktı: [10 20 30 40 50]  Orijinal veri değişmedi.

"""# Fancy indexing (tamsayı dizisi ile) — advanced

İndeks olarak bir dizi/ndarray kullanılır. Bu kopya döndürür ve sıra/tekrarı korur.
* Eğer satır ve sütun için ayrı diziler verirseniz, NumPy eleman-eleman eşleşme yapar (pairwise).

* Tekrarlanan indeksler tekrar eden elemanlar üretir.
"""

a = np.arange(10)
print(a)
indices = [2,5,5,1]
print(a[indices])   # [2 5 5 1]  (kopya)
print(a)
# 2D örnek:
M = np.arange(12).reshape(3,4)
print(M)
rows = np.array([0,2])
cols = np.array([1,3])
print(M[rows, cols]) # [1 11] -> (0,1) ve (2,3) elemanları

# Gerçek Hayat Örneği: Rastgele Örneklem Seçme
isim_indeksleri = np.array(['Ali', 'Ayşe', 'Can', 'Deniz', 'Ece', 'Furkan'])
puanlar = np.array([90, 75, 88, 62, 95, 81])

# Sadece 0. (Ali), 4. (Ece) ve 2. (Can) indekslerdeki kişilerin puanlarını çekmek
indeks_listesi = np.array([0, 4, 2])

secilen_isimler = isim_indeksleri[indeks_listesi]
secilen_puanlar = puanlar[indeks_listesi]

print(f"\nSeçilen İsimler (Rastgele): {secilen_isimler}")
print(f"Seçilen Puanlar: {secilen_puanlar}")
# Çıktı: [Ali Ece Can] ve [90 95 88]

"""# Boolean (mask) indexing — koşula göre seçme

Şartlı maske ile seçme — esnek ve çok güçlü.

Bir koşulun döndürdüğü True (Seç) veya False (Atla) değerlerine göre dizi elemanlarını filtreleme.
"""

x = np.arange(10)
mask = x % 2 == 0
print(mask)       # [ True False  True ... ]
print(x[mask])    # [0 2 4 6 8]

# Atama:
x[x % 3 == 0] = -1
print(x)  # elemanların bazılarının -1 olduğunu görürsünüz

# Gerçek Hayat Örneği: 5000'den fazla stok adedini filtreleme
stok_adedi = np.array([4500, 6200, 3100, 5800, 9500])

# 1. Koşul Dizisi (Maske) Oluşturma
maske = stok_adedi > 5000
print(f"Koşul Maskesi: {maske}")
# Çıktı: [False True False True True]

# 2. Maskeyi Uygulama (Sadece True olanlar seçilir)
yuksek_stok = stok_adedi[maske]
print(f"5000 üzeri Stoklar: {yuksek_stok}")
# Çıktı: [6200 5800 9500]

"""# Çoklu koşullar (& ve |)

Birden fazla koşulu birleştirmek için Python'daki and ve or yerine, NumPy'ın element-wise operatörleri **& (VE) ve | (VEYA)** kullanılır.
"""

# Gerçek Hayat Örneği: Maaş Filtreleme (50.000 üzeri VE 5 yıldan az tecrübe)
maaslar = np.array([45000, 60000, 75000, 52000, 48000])
tecrube = np.array([7, 3, 6, 2, 8])

# Koşul 1: Maaş > 50000
maske_maas = maaslar > 50000

# Koşul 2: Tecrübe < 5
maske_tecrube = tecrube < 5

# İki koşulu BİRLEŞTİRME (VE & operatörü)
filtre_maske = maske_maas & maske_tecrube

# Sonuç: Sadece 60000 (3 yıl) ve 52000 (2 yıl) bu koşulu sağlar
hedef_personel_maas = maaslar[filtre_maske]
print(f"\nFiltrelenen Personel Maaşları (VE koşulu): {hedef_personel_maas}")
# Çıktı: [60000 52000]

#karmaşık örnek : boolean + fancy

M = np.arange(12).reshape(3,4)
mask = M % 2 == 0
print(M[mask])  # 2D diziyi boolean mask ile 1D olarak döndürür

"""# Ellipsis (...) — bilinmeyen boyutlar için

Bazen boyut sayısı değişkense ... kullanışlıdır.
"""

A = np.zeros((2,3,4,5))
# İlk iki boyutu seç, geri kalanı tümünü al:
print(A)
sub = A[1, ...]   # eşdeğer: A[1, :, :, :]
print("/"*50)
print(sub)

dizi3 = np.arange(24).reshape(2, 3, 4)
print(dizi3)

"""
Boyutlar:

eksen (dış): 2 tane 3x4 matris

eksen (orta): 3 satır

eksen (iç): 4 sütun
"""

#normali
dizi3[:, :, 0]

#ellipsis ile

dizi3[..., 0]

# dört boyutlu dizi

dizi4 = np.arange(2*3*4*5).reshape(2, 3, 4, 5)
print(dizi4)



"""

Bu → ilk eksen 1 (ikinci blok), son eksen 0 (her 3x4’lük matristen ilk sütun).
Yani:

1 → 2. blok

... → aradaki 2 eksenin tüm elemanları

0 → son eksenin ilk elemanı

"""

dizi4[1, ..., 0]

"""# np.newaxis / None — eksen ekleme

Boyut (axis) eklemek veya broadcasting için kullanılır.
Bu genelde broadcasting, vektör/matris işlemleri veya veri şekillendirme (reshaping) için kullanılır.

her NumPy dizisinin bir şekli (shape) vardır.

np.newaxis kullanarak o şekle yeni bir eksen eklenir.

np.newaxis ve None aynı şeyi yapar.
"""

v = np.array([1,2,3])        # shape (3,)
print(v)
v_row = v[np.newaxis, :]     # shape (1,3)
print(v_row)
v_col = v[:, np.newaxis]     # shape (3,1)
print(v_col)

#np.newaxis yerine None da kullanılabilir


dizi = np.array([10,20,30])
print(dizi)
vektor_satir = dizi[:, None]
print(vektor_satir)
vektor_sutun = dizi[None, :]
print(vektor_sutun)

# 2d -> 3D

matris = np.array([
    [1, 2, 3],
    [4, 5, 6]
])
print(matris.shape)
matris_3d = matris[:, :, np.newaxis]
print(matris_3d.shape)
print(matris_3d)

# broadcasting için kullanım
#newaxis, boyutları eşitlemek için kullanılır

a = np.array([1, 2, 3])        # (3,)
b = np.array([10, 20, 30])     # (3,)
print(a*b)
#normalde a*b mümküm çünkü ikiside (3,) (3,)

b = b[:, np.newaxis]  # (3, 1)
print(b)
print(a)
print(a*b)
sonuc = a + b
print(sonuc)
print(sonuc.shape)

"""# where, nonzero ile indeks alma

Koşul sağlayan indekslerin pozisyonunu almak isterseniz:
"""

a = np.array([0, 5, 2, 5, 0, 3])
idx = np.where(a == 5)    # (array([1, 3]),)
print(idx[0])             # [1 3]

# nonzero:
print(a.nonzero())        # aynı sonucu verir

"""# Atama ile indeksleme (güçlü kullanım)

Seçilen yerlere değer atama:

Dikkat: Fancy indexing ile atama bir copy üzerinde yapılırsa orijinal değişmez. Çoklu indeksleme ile doğrudan atama yaparken kopya mı yoksa view mi olduğuna dikkat edin.
"""

arr = np.arange(10)
print(arr)
arr[[1,3,5]] = -10
print(arr)  # 1,3,5 indeksleri -10 olur

# boolean ile:
arr[arr < 0] = 0
print(arr)

"""
İndeksleme ile broadcast (yayılma) örnekleri

Tek bir değer atamak yerine, uygun şekle getirilmiş bir dizi kullanarak broadcasting yapabilirsiniz:
"""

M = np.zeros((3,4))
M[:, 1] = np.array([1,2,3])   # shape (3,) ile sütuna atama → broadcast değil, doğrudan uyan shape
# veya
M[np.array([0,1,2]), 2] = [10,20,30]  # eleman-eleman atama

"""
Çok boyutlu ilerleme (advanced slicing)

Adım ve negatif step de 2D/3D’de kullanılabilir.

"""
M = np.arange(16).reshape(4,4)

print(M[::2, ::2])   # her 2. satır ve sütun
print(M[::-1, ::-1]) # tersine döndürülmüş matris

"""#Dilimleme vs Fancy — performans farkı

Slicing → view, hafıza paylaşımı — hızlı, hafıza verimli.

Fancy / boolean → kopya — gerektiğinde hızlı ve esnek ama bellek kullanımı artar.
"""

#çok boyutlu fancy indexing örneği

M = np.arange(12).reshape(3,4)
print(M)
rows = [0,1]
cols = [1,2]
print(M[rows][:, cols])   # farklı sonuç: M[rows] önce alt-matris (kopya) verir, sonra sütun seçilir
print(M[np.ix_(rows, cols)])  # doğru şekilde (0,1) ve (1,2) alt-matrisini verir

#np.ix_ kombinasyonu, iki 1-D indeks listesiyle 2-D alt-matris almak için kullanılır.

"""## ⚠️ Yaygın Tuzaklar / Dikkat Edilmesi Gerekenler

- **Slicing view döndürür** — dilim üzerinden yaptığınız değişiklik **orijinali değiştirir**.  
  → Eğer kopya istiyorsanız `.copy()` kullanın.

- **Fancy indexing kopya döndürür** — bu nedenle büyük dizilerde **bellek kullanımı artar.**

- **Boolean indexing** kullanırken orijinalin `shape`’i bozulur:  
  → `M[mask]` genelde **1D** döndürür.

- **Adım (step) float olamaz** — slice adımı sadece **integer** olabilir.  
  → Ondalık adımlar istenirse `np.linspace` kullanın.

- **Atama yaparken shape uyumu gereklidir** — broadcasting kurallarına uymazsa **hata verir.**

- `M[rows][:, cols]` ile `M[rows, cols]` veya `M[np.ix_(rows, cols)]` **farklı davranır** — dikkat!

---

## 🧰 Kullanışlı İpuçları & Yardımcı Fonksiyonlar

- `np.take(a, indices, axis=...)` — fancy indexing alternatifi, belirli bir eksen üzerinden alma.  
- `np.put(a, indices, values, mode='raise')` — belirli konumlara değer yerleştirme.  
- `np.choose`, `np.compress`, `np.extract` — belirli seçim işlemleri için.  
- `np.argwhere(condition)` — koşulu sağlayan **indeksleri (satır-sütun çiftleri)** döndürür.

---

## 🧾 Özet — Kısa Referans

| Yazım | Açıklama |
|-------|-----------|
| `a[i]` | Tek indeks |
| `a[start:stop:step]` | Slice (view) |
| `a[rows, cols]` | Çok boyutlu doğrudan indeksleme |
| `a[[i1, i2]]` | Fancy indexing (kopya) |
| `a[mask]` | Boolean indexing (kopya) |
| `a[..., i]` | Ellipsis (tüm eksenleri kapsar) |
| `a[np.newaxis]` veya `a[None]` | Eksen ekleme |
| `np.where`, `np.nonzero` | İndeks/konum bulma |
| `np.ix_` | 2D / ND için çapraz tamsayı indeksleme |

"""

# =========================
# JUPYTER NOTEBOOK: NumPy İndeksleme
# =========================

import numpy as np

# --------------------------------
# 1. 1D Dizi ve Temel İndeksleme
# --------------------------------
print("1️⃣ 1D Dizi ve Temel İndeksleme")
a = np.arange(10)
print("Dizi a:", a)

print("\na[0] ->", a[0])
print("a[-1] ->", a[-1])
print("a[3] ->", a[3])

# --------------------------------
# 2. Dilimleme / Slicing
# --------------------------------
print("\n2️⃣ Dilimleme / Slicing")
print("a[2:7] ->", a[2:7])
print("a[:5] ->", a[:5])
print("a[5:] ->", a[5:])
print("a[::2] ->", a[::2])
print("a[::-1] ->", a[::-1])

# Slice view örneği
b = a[2:5]
b[:] = 100
print("Slice b = a[2:5], b[:] = 100 → a dizisi:", a)

# --------------------------------
# 3. 2D Dizi ve Çok Boyutlu İndeksleme
# --------------------------------
print("\n3️⃣ 2D Dizi ve Çok Boyutlu İndeksleme")
M = np.arange(12).reshape(3,4)
print("Dizi M:\n", M)

print("M[0, 1] ->", M[0,1])
print("M[1] ->", M[1])
print("M[:, 2] ->", M[:,2])
print("M[0:2, 1:3] ->\n", M[0:2,1:3])

# --------------------------------
# 4. Fancy Indexing (Tamsayı ile)
# --------------------------------
print("\n4️⃣ Fancy Indexing")
rows = [0,2]
cols = [1,3]
print("M[rows, cols] ->", M[rows, cols])

# --------------------------------
# 5. Boolean Indexing
# --------------------------------
print("\n5️⃣ Boolean Indexing")
mask = M % 2 == 0
print("Mask (çift sayılar):\n", mask)
print("M[mask] ->", M[mask])

# Atama örneği
M[M % 3 == 0] = -1
print("M dizisi (3 ile bölünebilenler -1 oldu):\n", M)

# --------------------------------
# 6. np.ix_ ile çapraz fancy indexing
# --------------------------------
rows = [0,1]
cols = [1,2]
sub = M[np.ix_(rows, cols)]
print("\n6️⃣ np.ix_ ile alt-matris:\n", sub)

# --------------------------------
# 7. np.newaxis / None ile eksen ekleme
# --------------------------------
v = np.array([1,2,3])
v_row = v[np.newaxis, :]
v_col = v[:, np.newaxis]
print("\n7️⃣ Ekseni değiştirme / np.newaxis")
print("v shape:", v.shape)
print("v_row shape:", v_row.shape)
print("v_row:\n", v_row)
print("v_col shape:", v_col.shape)
print("v_col:\n", v_col)

# --------------------------------
# 8. where ve nonzero ile indeks alma
# --------------------------------
a = np.array([0,5,2,5,3])
idx_where = np.where(a==5)
idx_nonzero = a.nonzero()
print("\n8️⃣ np.where ve nonzero")
print("np.where(a==5) ->", idx_where[0])
print("a.nonzero() ->", idx_nonzero[0])

# --------------------------------
# 9. Karmaşık slicing örnekleri
# --------------------------------
M = np.arange(16).reshape(4,4)
print("\n9️⃣ Karmaşık slicing örnekleri")
print("M dizisi:\n", M)
print("M[::2, ::2] ->\n", M[::2, ::2])
print("M[::-1, ::-1] ->\n", M[::-1, ::-1])

# --------------------------------
# 10. Mini uygulama: Dizi seçme ve değiştirme
# --------------------------------
print("\n🔟 Mini Uygulama")
arr = np.arange(1, 21).reshape(4,5)
print("Başlangıç dizisi:\n", arr)

# 2. satır ve 3. sütundaki elemanı 99 yap
arr[1,2] = 99
# tüm çift sayıları -1 yap
arr[arr % 2 == 0] = -1
print("Güncellenmiş dizi:\n", arr)

#Genel Örnek 2

# Detaylı Dilimleme Örnekleri
dizi = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print("Orijinal dizi:", dizi)

# Temel dilimleme
print("dizi[2:7]:", dizi[2:7])           # [2, 3, 4, 5, 6]
print("dizi[:5]:", dizi[:5])             # İlk 5 eleman [0, 1, 2, 3, 4]
print("dizi[5:]:", dizi[5:])             # 5'ten sonra [5, 6, 7, 8, 9]
print("dizi[::2]:", dizi[::2])           # Bir atlayarak [0, 2, 4, 6, 8]
print("dizi[::-1]:", dizi[::-1])         # Ters çevir [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
print("---")

# 2B Dizide Dilimleme
matrix = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8],
                  [9, 10, 11, 12],
                  [13, 14, 15, 16]])
print("Orijinal matrix:\n", matrix)

# Satır dilimleme
print("İlk 2 satır:\n", matrix[:2, :])           # Satır 0 ve 1
print("Son satır:\n", matrix[-1, :])             # Son satır
print("Çift indeksli satırlar:\n", matrix[::2, :]) # 0, 2. satırlar

# Sütun dilimleme
print("İlk 2 sütun:\n", matrix[:, :2])           # Sütun 0 ve 1
print("Son sütun:\n", matrix[:, -1])             # Son sütun
print("Bir atlayarak sütunlar:\n", matrix[:, ::2]) # 0, 2. sütunlar

# Hem satır hem sütun dilimleme
print("2x2 alt matrix:\n", matrix[1:3, 1:3])     # Satır 1-2, Sütun 1-2
print("---")

# VIEW vs COPY - KRİTİK KONU!
print("=== VIEW vs COPY ===")
original = np.array([10, 20, 30, 40, 50])

# VIEW oluşturma (veri paylaşır)
view_dizi = original[1:4]                # Dilimleme VIEW döndürür
print("Original:", original)
print("View:", view_dizi)

# View'de değişiklik original'i etkiler!
view_dizi[0] = 999
print("View değiştikten sonra Original:", original)  # [10, 999, 30, 40, 50]

# COPY oluşturma (yeni veri)
original[1] = 20  # Eski haline getir
copy_dizi = original[1:4].copy()         # .copy() ile kopya oluştur
print("Copy:", copy_dizi)

# Copy'de değişiklik original'i ETKİLEMEZ!
copy_dizi[0] = 888
print("Copy değiştikten sonra Original:", original)  # Değişmez [10, 20, 30, 40, 50]
print("---")

# Hangi durumlarda COPY oluşur?
print("Dilimleme → VIEW")
print("Boolean indeksleme → COPY")
print("Fancy indeksleme → COPY")
print(".copy() metodu → COPY")

# Boolean indeksleme COPY döndürür
bool_mask = original > 25
bool_selection = original[bool_mask]     # Bu bir COPY!
print("Boolean selection is copy?", bool_selection.base is None)  # True

"""#Dizileri tekrar şekillendirmek

Elimizde bulunan tek boyutlu veya çok boyutlu dizileri tekrar boyut ayarlaması yapmak isteyebilirzi bu gibi durumlarda reshape özelliği kullanabiliriz
"""

import numpy as np
dizi = np.arange(1,16)
print(dizi)

print(dizi.reshape(3,5))

dizi = np.arange(1,21).reshape(4,5)
dizi

# randint ve reshape ile rastgele sayılardan matris oluşturma

# 0 ile 100 arasında 12 adet rastgele tam sayı üret
rastgele_sayilar = np.random.randint(0, 101, 12)
print("Oluşturulan rastgele 1D dizi:", rastgele_sayilar)

# 1D diziyi 3 satır ve 4 sütunlu bir matrise dönüştür
matris_yeniden_sekillendirilmis = rastgele_sayilar.reshape(3, 4)
print("\nYeniden şekillendirilmiş 2D matris:\n", matris_yeniden_sekillendirilmis)

# Gerçek Hayat Örneği: Sensör Verisinin 1D'den 2D'ye Çevrilmesi
# Bir saatte 6 saniyede bir alınan 30 adet ölçüm.
olcumler_1d = np.arange(30)
print(f"Başlangıç Shape: {olcumler_1d.shape}") # (30,)

# 1. 5 Satır, 6 Sütun Yapma (5 dakikalık 6 periyot)
matris_5x6 = olcumler_1d.reshape(5, 6)
print(f"\n5x6 Matris:\n{matris_5x6}")

# 2. Otomatik Hesaplama için -1 Kullanımı
# Sütun sayısını 10 olarak belirle, satırı NumPy hesaplasın (30/10=3).
matris_otomatik_satir = olcumler_1d.reshape(-1, 10)
print(f"\nOtomatik Satır (Shape: {matris_otomatik_satir.shape}):\n{matris_otomatik_satir}")
# Çıktı: (3, 10)

# 3. Model Girdisi Formatı (Özellik Vektörü)
# 1D vektörü, makine öğrenimi için (30, 1) şeklinde 2D matrise çevirme
vektor_sutun = olcumler_1d.reshape(-1, 1)
print(f"\n(30, 1) Sutün Vektör Shape: {vektor_sutun.shape}")

"""#arraylerde birleştirme

| Fonksiyon           | Açıklama                                                                        |
| ------------------- | ------------------------------------------------------------------------------- |
| `np.concatenate()`  | Dizileri belirli bir axis boyunca birleştirir.                                  |
| `np.vstack()`       | Dizileri **dikey** olarak üst üste birleştirir (row-wise).                      |
| `np.hstack()`       | Dizileri **yatay** olarak yan yana birleştirir (column-wise).                   |
| `np.stack()`        | Yeni bir eksen (axis) ekleyerek birleştirir.                                    |
| `np.column_stack()` | 1D dizileri **sütun olarak** birleştirir, 2D dizilerde yatay birleştirme yapar. |
| `np.row_stack()`    | `vstack` ile aynı işlevi görür.                                                 |

**Tek boyutlu dizilerde birleştirme**
"""

dizi1 =  np.array([1,2,3,4,5])
dizi2 =  np.array([10,20,30,40,50])

#birleştirmek için
np.concatenate([dizi1, dizi2])
#np.concatenate([dizi1, dizi2,dizi3,....]) çok sayıda diziyi birleştirebiliriz

import numpy as np

a = np.array([1,2,3])
b = np.array([4,5,6])

# concatenate
c = np.concatenate([a,b])
print("concatenate:", c)

# hstack
d = np.hstack([a,b])
print("hstack:", d)

# vstack
e = np.vstack([a,b])
print("vstack:\n", e)

"""**çok boyutlu dizileri birleştirme**"""

dizi1=np.array([[1,2,3],[4,5,6]])
dizi2=np.array([[7,8,9],[10,11,12]])

np.concatenate([dizi1, dizi2])

X = np.array([[1,2],[3,4]])
Y = np.array([[5,6],[7,8]])

# axis=0 → satırları birleştirir (alt alta)
print("concatenate axis=0:\n", np.concatenate([X,Y], axis=0))

# axis=1 → sütunları birleştirir (yan yana)
print("concatenate axis=1:\n", np.concatenate([X,Y], axis=1))

# vstack → axis=0 ile aynı
print("vstack:\n", np.vstack([X,Y]))

# hstack → axis=1 ile aynı
print("hstack:\n", np.hstack([X,Y]))

"""
np.stack() — Yeni eksen ile birleştirme

stack, dizileri yeni bir boyut ekleyerek birleştirir.

"""
X = np.array([1,2,3])
Y = np.array([4,5,6])

Z = np.stack([X,Y], axis=0)
print("axis=0 ile stack:\n", Z)
print("shape:", Z.shape)

Z2 = np.stack([X,Y], axis=1)
print("axis=1 ile stack:\n", Z2)
print("shape:", Z2.shape)

#column_stack ve row_stack

a = np.array([1,2,3])
b = np.array([4,5,6])

# sütun olarak birleştirme
print("column_stack:\n", np.column_stack([a,b]))

# row_stack → vstack ile aynı
print("row_stack:\n", np.row_stack([a,b]))

"""| Fonksiyon      | 1D Dizi | 2D Dizi | Yeni Boyut?             |
| -------------- | ------- | ------- | ----------------------- |
| `concatenate`  | ✔       | ✔       | ❌                       |
| `vstack`       | ✔       | ✔       | ❌ (axis=0)              |
| `hstack`       | ✔       | ✔       | ❌ (axis=1)              |
| `stack`        | ✔       | ✔       | ✔ (axis ile yeni boyut) |
| `column_stack` | ✔       | ✔       | ❌                       |
| `row_stack`    | ✔       | ✔       | ❌                       |


İpucu:

1D dizilerde hstack = concatenate, vstack → 2D dizi

2D dizilerde axis=0 → satır, axis=1 → sütun
"""

# =========================
# JUPYTER NOTEBOOK: NumPy Dizileri Birleştirme
# =========================
import numpy as np

print("🔹 NumPy Dizileri Birleştirme Aracı")

# -----------------------------
# 1️⃣ Kullanıcıdan dizileri oluştur
# -----------------------------
print("\nOluşturulacak ilk diziyi belirtin (örn: 1,2,3,4):")
dizi1_str = input("Dizi 1: ")
dizi1 = np.array([int(x.strip()) for x in dizi1_str.split(",")])

print("Oluşturulacak ikinci diziyi belirtin (örn: 5,6,7,8):")
dizi2_str = input("Dizi 2: ")
dizi2 = np.array([int(x.strip()) for x in dizi2_str.split(",")])

# Dizi boyutlarını isteğe göre değiştirebilirsiniz
reshape_input = input("\nDizileri 2D yapmak ister misiniz? (evet/hayır): ").strip().lower()
if reshape_input == "evet":
    rows1 = int(input("Dizi 1 için satır sayısı: "))
    cols1 = int(input("Dizi 1 için sütun sayısı: "))
    dizi1 = dizi1.reshape(rows1, cols1)

    rows2 = int(input("Dizi 2 için satır sayısı: "))
    cols2 = int(input("Dizi 2 için sütun sayısı: "))
    dizi2 = dizi2.reshape(rows2, cols2)

print("\nDizi 1:\n", dizi1)
print("Dizi 2:\n", dizi2)

# -----------------------------
# 2️⃣ Birleştirme yöntemini seç
# -----------------------------
print("\nBirleştirme yöntemi seçenekleri:")
print("1: concatenate (axis belirtin)")
print("2: vstack")
print("3: hstack")
print("4: stack (axis belirtin)")
print("5: column_stack")
print("6: row_stack")

secim = input("Seçiminiz (1-6): ").strip()

if secim == "1":
    axis = int(input("concatenate için axis (0 veya 1): "))
    sonuc = np.concatenate([dizi1, dizi2], axis=axis)
elif secim == "2":
    sonuc = np.vstack([dizi1, dizi2])
elif secim == "3":
    sonuc = np.hstack([dizi1, dizi2])
elif secim == "4":
    axis = int(input("stack için axis (0,1,...): "))
    sonuc = np.stack([dizi1, dizi2], axis=axis)
elif secim == "5":
    sonuc = np.column_stack([dizi1, dizi2])
elif secim == "6":
    sonuc = np.row_stack([dizi1, dizi2])
else:
    print("Geçersiz seçim")
    sonuc = None

# -----------------------------
# 3️⃣ Sonucu göster
# -----------------------------
if sonuc is not None:
    print("\n✅ Birleştirilmiş Dizi:\n", sonuc)
    print("Shape:", sonuc.shape)

#farkli dizileri dikey ve yatayda birlştirme

# İki Farklı Bölgeden Gelen Aylık Sıcaklık Verisi
bolge_a_sicaklik = np.array([20, 22, 21])
bolge_b_sicaklik = np.array([18, 20, 19])

# Dikey Birleştirme (axis=0): Veriyi alt alta ekle (Satır bazında)
birlesik_dikey = np.concatenate([bolge_a_sicaklik, bolge_b_sicaklik], axis=0)
print(f"Dikey Birleştirme: {birlesik_dikey}")
# Çıktı: [20 22 21 18 20 19]

# Yatay Birleştirme (axis=1): Sütun bazında (Özellik ekleme)
# 2D formatına çeviriyoruz ki sütun bazında birleştirebilelim
A_matris = bolge_a_sicaklik.reshape(-1, 1) # (3, 1)
B_matris = bolge_b_sicaklik.reshape(-1, 1) # (3, 1)

birlesik_yatay = np.concatenate([A_matris, B_matris], axis=1)
print(f"\nYatay Birleştirme (Shape: {birlesik_yatay.shape}):\n{birlesik_yatay}")
# Çıktı: [[20 18] [22 20] [21 19]] (Aynı ölçüm anının A ve B bölgesi verisi)

"""# **Dizilerde Bölme İşlemleri**

| Fonksiyon          | Açıklama                                                                           |
| ------------------ | ---------------------------------------------------------------------------------- |
| `np.split()`       | Diziyi **belirtilen indekslerden** böler.                                          |
| `np.array_split()` | Diziyi **yaklaşık eşit parçalar** halinde böler. (split’de tam bölünme şart değil) |
| `np.hsplit()`      | Çok boyutlu dizileri **sütun bazlı** böler (axis=1).                               |
| `np.vsplit()`      | Çok boyutlu dizileri **satır bazlı** böler (axis=0).                               |
| `np.dsplit()`      | 3D ve üstü dizileri **derinlik ekseni** boyunca böler (axis=2).                    |

"""

# 1d dizilerde bölme

import numpy as np

a = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]

# np.split ile indekslerden bölme
print("np.split([3,7]):", np.split(a, [3,7]))
# 0:3, 3:7, 7:end → [[0 1 2], [3 4 5 6], [7 8 9]]

# np.array_split ile yaklaşık eşit parçalar
print("np.array_split(3):", np.array_split(a, 3))
# yaklaşık eşit 3 parça → [[0 1 2 3], [4 5 6], [7 8 9]]

#Fark: np.split sadece tam bölünebilen dizilerde çalışır; np.array_split ise kalanları dengeler.

# 2d dizilerde bölme

M = np.arange(16).reshape(4,4)
print("Dizi M:\n", M)

# Satır bazlı bölme (vsplit)
print("vsplit 2 parçaya:\n", np.vsplit(M, 2))

# Sütun bazlı bölme (hsplit)
print("hsplit 2 parçaya:\n", np.hsplit(M, 2))

"""
Çok Boyutlu Dizilerde Bölme

dsplit → 3D dizilerde derinlik ekseni boyunca

hsplit → axis=1

vsplit → axis=0
"""

A = np.arange(24).reshape(2,3,4)  # shape (2,3,4)
print(A)
print("dsplit 2 parçaya:\n", np.dsplit(A, 2))

#diziyi satır sütün olarka böl

M = np.arange(1,17).reshape(4,4)
print("Orijinal dizi:\n", M)

satir_parcalari = np.vsplit(M, 2)
sutun_parcalari = np.hsplit(M, 2)

print("\nSatır bazlı 2 parça:")
for p in satir_parcalari:
    print(p)

print("\nSütun bazlı 2 parça:")
for p in sutun_parcalari:
    print(p)

"""**Dikkat**
1. split tam bölünme ister. Bölünemiyorsa hata verir.

`np.split(np.arange(10), 3)  # HATA!`


2. array_split → yaklaşık eşit parçalara böler, kalanları dengeler.

`np.array_split(np.arange(10), 3)  # [[0 1 2 3], [4 5 6], [7 8 9]]`


3. hsplit ve vsplit → 2D veya daha fazla boyutlu dizilerde kolay kullanım sağlar.

# Transpose Nedir ?

Transpose, bir matrisin satır ve sütunlarını yer değiştirme işlemidir.

2D dizilerde: M.T → satırlar sütun, sütunlar satır olur.

ND dizilerde: np.transpose → istenirse eksenlerin sırası değiştirilebilir.
"""

#2d dizilerde transpose

import numpy as np

M = np.array([[1,2,3],
              [4,5,6]])
print("Orijinal Dizi:\n", M)

# Transpose
MT = M.T
print("\nTranspoze:\n", MT)

#1d transpose

v = np.array([1,2,3])
print("v:", v)
print("v.T:", v.T)

"""
3D veya ND Dizilerde Transpose

3D dizilerde veya daha üst boyutlarda np.transpose ile ekseni değiştirebilirsin.
"""
A = np.arange(24).reshape(2,3,4)
print("Orijinal shape:", A.shape)

# Eksenleri değiştir (0,2,1)
B = np.transpose(A, (0,2,1))
print("Yeni shape:", B.shape)

#Orijinal shape: (2,3,4) → Yeni shape: (2,4,3)
#Ekseni (0,2,1) ile ilk ekseni koruduk, ikinci ve üçüncü ekseni yer değiştirdik.

#transpose vs swapaxes

#transpose → tüm eksenleri yeniden sıralama
#swapaxes → sadece iki ekseni değiştirir

C = np.arange(12).reshape(2,3,2)
print("Orijinal shape:", C.shape)
print(C)

D = C.swapaxes(1,2)
print("swapaxes(1,2) shape:", D.shape)
print(D)

"""# Matris Çarpımı (np.dot / @) (EK KONU)
Oturum 1'deki * (element-wise çarpım) ile karıştırılmamalıdır. Matris Çarpımı, Lineer Cebir kurallarına uyar.


"""

X = np.array([[1,2,3],
              [4,5,6]])

# Transpoze ile matris çarpımı
XT = X.T
print("X.T @ X:\n", XT @ X)

# Gerçek Hayat Örneği: Ağırlıklı Ortalama/Skor Hesaplama
# Matris A: 4 öğrencinin 2 dersten aldığı puan (4x2)
puanlar = np.array([[90, 70], [80, 60], [75, 85], [95, 75]])

# Vektör B: Derslerin Kredileri/Ağırlıkları (2x1)
krediler = np.array([[0.6], [0.4]]) # Krediler [Ders1, Ders2]

# Matris Çarpımı (np.dot veya @)
# (4x2) @ (2x1) = (4x1) -> Her öğrencinin toplam ağırlıklı puanı
toplam_puan = puanlar @ krediler
# VEYA: toplam_puan = np.dot(puanlar, krediler)

print(f"Ağırlıklı Puanlar (Matris Çarpımı Sonucu):\n{toplam_puan.round(2)}")
# Çıktı:
# [[82.0]  (90*0.6 + 70*0.4)
#  [72.0]
#  [79.0]
#  [87.0]]

"""# Tekrar Kodları"""

# 1. VIEW vs COPY Farkını Anla - PERFORMANS KRİTİK!
dizi = np.array([1, 2, 3, 4, 5])
view = dizi[1:4]    # VIEW - hızlı, bellek verimli
copy = dizi[1:4].copy()  # COPY - yavaş, fazla bellek

# 2. Boolean Indexing'de Parantez Kullan
# YANLIŞ: dizi > 5 and dizi < 10
# DOĞRU: (dizi > 5) & (dizi < 10)

# 3. Büyük Dizilerde .copy() Kullanımına Dikkat Et
buyuk_dizi = np.random.rand(1000000)
# Kötü: yeni_dizi = buyuk_dizi[::2]  # VIEW, orijinali silinemez
# İyi: yeni_dizi = buyuk_dizi[::2].copy()  # COPY, orijinal silinebilir

# 4. reshape()'te -1 Kullanarak Kodunu Esnek Yap
dizi = np.arange(24)
otomatik = dizi.reshape(2, 3, -1)  # NumPy 4 hesaplar: 24/(2*3)=4

# 5. Rastgele Sayılarda seed() Kullan - Reprodücibility
np.random.seed(42)  # Aynı sonuçları garanti eder

# 6. Boolean Maskeleri Önceden Hesapla - OKUNABİLİRLİK
dizi = np.random.rand(1000)
kosul = (dizi > 0.3) & (dizi < 0.7)
sonuc = dizi[kosul]  # Daha okunabilir

# 7. Fancy Indexing Yerine Boolean Indexing Tercih Et - PERFORMANS
# Daha hızlı: dizi[dizi > 5]
# Daha yavaş: dizi[[i for i in range(len(dizi)) if dizi[i] > 5]]

# 8. Çok Boyutlu Dizilerde axis Parametresini Doğru Anla
matrix = np.random.rand(3, 4)
toplam_satir = matrix.sum(axis=1)  # Satırlar boyunca
toplam_sutun = matrix.sum(axis=0)  # Sütunlar boyunca

# 9. Büyük Dizileri İşlerken Bellek Kullanımını İzle
import sys
dizi = np.ones((1000, 1000))
print(f"Bellek kullanımı: {dizi.nbytes / 1024 / 1024:.2f} MB")

# 10. np.where() ile Koşullu İşlemleri Vektörel Yap
dizi = np.array([1, 2, 3, 4, 5])
# Kötü: [x if x > 3 else 0 for x in dizi]  # Python döngüsü - yavaş
# İyi: np.where(dizi > 3, dizi, 0)  # Vektörel işlem - hızlı

"""**ileri dilimleme teknikleri**"""

# np.newaxis - Boyut Ekleme
dizi = np.array([1, 2, 3])
print("Orijinal shape:", dizi.shape)  # (3,)
print("newaxis ile sütun vektörü:", dizi[:, np.newaxis].shape)  # (3, 1)
print("newaxis ile satır vektörü:", dizi[np.newaxis, :].shape)  # (1, 3)

# np.ix_ - Karmaşık Indexing
matrix = np.arange(25).reshape(5, 5)
rows = [1, 3, 4]
cols = [0, 2, 4]
print("ix_ ile seçim:\n", matrix[np.ix_(rows, cols)])

"""# np.put ve np.take"""

# np.put - Belirli indekslere değer atama
dizi = np.array([10, 20, 30, 40, 50])
np.put(dizi, [0, 2, 4], [100, 300, 500])
print("put sonrası:", dizi)  # [100, 20, 300, 40, 500]

# np.take - Belirli indekslerden değer alma
alinan = np.take(dizi, [1, 3])
print("take ile alınan:", alinan)  # [20, 40]

"""
* örnek 1 Hisse senedi fiyat analizi

"""

import numpy as np

# Gerçek hayat senaryosu: Bir hisse senedinin 10 günlük kapanış fiyatlarını analiz etme
print("=== ÖRNEK 1: Hisse Senedi Fiyat Analizi ===")

# 10 günlük hisse senedi kapanış fiyatları (TL)
gunluk_fiyatlar = [145.50, 148.20, 152.75, 149.30, 155.80, 153.25, 158.90, 162.40, 159.75, 164.20]
hisse_fiyatlari = np.array(gunluk_fiyatlar)

print(f"10 günlük hisse fiyatları: {hisse_fiyatlari}")
print(f"Veri tipi: {hisse_fiyatlari.dtype}")  # float64 - ondalıklı sayılar için uygun
print(f"Boyut: {hisse_fiyatlari.shape}")     # (10,) - 10 elemanlı 1B dizi

# Günlük getiri oranlarını hesapla (yüzde değişim)
getiri_oranlari = (hisse_fiyatlari[1:] - hisse_fiyatlari[:-1]) / hisse_fiyatlari[:-1] * 100
print(f"Günlük getiri oranları (%): {getiri_oranlari}")

# Ortalama getiri ve volatilite (risk)
ortalama_getiri = np.mean(getiri_oranlari)
volatilite = np.std(getiri_oranlari)
print(f"Ortalama günlük getiri: %{ortalama_getiri:.2f}")
print(f"Günlük volatilite: %{volatilite:.2f}")

"""
AÇIKLAMALAR:
- np.array(): Python listesini NumPy dizisine çevirir
- dtype: Verilerin float64 olması ondalıklı fiyatlar için ideal
- shape: (10,) 10 elemanlı tek boyutlu dizi olduğunu gösterir
- [1:] ve [:-1]: Diziyi kaydırarak günlük farkları hesaplar
- np.mean() ve np.std(): İstatistiksel hesaplamalar için kullanılır
"""

"""# sıcaklık verisi işleme"""

import numpy as np

# Gerçek hayat senaryosu: Bir haftalık sıcaklık ölçümlerini işleme
print("\n=== ÖRNEK 2: Sıcaklık Verisi İşleme ===")

# 7 günlük ortalama sıcaklık verisi (°C)
sicaklik_verisi = [22.5, 24.3, 19.8, 21.2, 26.7, 28.1, 23.4]
sicaklik_dizisi = np.array(sicaklik_verisi)

print(f"7 günlük sıcaklık verisi: {sicaklik_dizisi}")

# Haftalık sıcaklık istatistikleri
max_sicaklik = np.max(sicaklik_dizisi)
min_sicaklik = np.min(sicaklik_dizisi)
ortalama_sicaklik = np.mean(sicaklik_dizisi)

print(f"En yüksek sıcaklık: {max_sicaklik}°C")
print(f"En düşük sıcaklık: {min_sicaklik}°C")
print(f"Ortalama sıcaklık: {ortalama_sicaklik:.1f}°C")

# Sıcaklık sınıflandırması
sinif_esikleri = [0, 15, 25, 35, 50]  # Soğuk, Ilık, Sıcak, Çok sıcak
sinif_etiketleri = ['Soğuk', 'Ilık', 'Sıcak', 'Çok Sıcak']

for i, sicaklik in enumerate(sicaklik_dizisi):
    for j, esik in enumerate(sinif_esikleri[:-1]):
        if esik <= sicaklik < sinif_esikleri[j+1]:
            print(f"Gün {i+1}: {sicaklik}°C → {sinif_etiketleri[j]}")
            break

"""
AÇIKLAMALAR:
- np.max() ve np.min(): Dizideki maksimum ve minimum değerleri bulur
- np.mean(): Ortalama hesaplar
- enumerate(): Hem indeksi hem değeri almak için kullanılır
- Sınıflandırma: Gerçek hayatta hava durumu analizlerinde kullanılır
"""

"""# öğrenci notları ve istatistik"""

import numpy as np

# Gerçek hayat senaryosu: Bir sınıfın sınav notlarını analiz etme
print("\n=== ÖRNEK 3: Öğrenci Notları Analizi ===")

# 20 öğrencinin matematik sınav notları (0-100 arası)
ogrenci_notlari = np.array([85, 92, 78, 65, 45, 88, 95, 72, 58, 81,
                            67, 90, 76, 53, 49, 87, 94, 79, 62, 84])

print(f"Öğrenci notları: {ogrenci_notlari}")

# Temel istatistikler
ortalama = np.mean(ogrenci_notlari)
medyan = np.median(ogrenci_notlari)
standart_sapma = np.std(ogrenci_notlari)

print(f"Sınıf ortalaması: {ortalama:.1f}")
print(f"Medyan: {medyan}")
print(f"Standart sapma: {standart_sapma:.1f}")

# Not dağılımı analizi
gecme_notu = 60
gecen_ogrenci_sayisi = np.sum(ogrenci_notlari >= gecme_notu)
kalan_ogrenci_sayisi = np.sum(ogrenci_notlari < gecme_notu)

print(f"Geçen öğrenci sayısı: {gecen_ogrenci_sayisi}")
print(f"Kalan öğrenci sayısı: {kalan_ogrenci_sayisi}")
print(f"Başarı oranı: %{(gecen_ogrenci_sayisi / len(ogrenci_notlari)) * 100:.1f}")

"""
AÇIKLAMALAR:
- np.median(): Ortanca değeri bulur (aykırı değerlere daha dayanıklı)
- np.sum() + boolean indexing: Koşulu sağlayan elemanları sayar
- >= ve < operatörleri: NumPy'da element-wise çalışır (her eleman için ayrı değerlendirir)
"""

import numpy as np

# Gerçek hayat senaryosu: 5 mağazanın aylık satış verileri
print("\n=== ÖRNEK 4: Mağaza Satış Analizi ===")

# 5 mağazanın 3 aylık satış verileri (bin TL)
satis_verisi = [
    [120, 150, 180],  # Mağaza 1
    [90, 110, 130],   # Mağaza 2
    [200, 220, 240],  # Mağaza 3
    [80, 95, 110],    # Mağaza 4
    [160, 170, 190]   # Mağaza 5
]

satis_dizisi = np.array(satis_verisi)
print(f"Satış verisi (5 mağaza x 3 ay):\n{satis_dizisi}")

# Toplam satışlar
aylik_toplam = np.sum(satis_dizisi, axis=0)  # Sütunlar boyunca toplam
magaza_toplam = np.sum(satis_dizisi, axis=1)  # Satırlar boyunca toplam
genel_toplam = np.sum(satis_dizisi)

print(f"Aylık toplam satışlar: {aylik_toplam} bin TL")
print(f"Mağaza toplam satışları: {magaza_toplam} bin TL")
print(f"Genel toplam satış: {genel_toplam} bin TL")

# Büyüme oranları
ilk_ay = satis_dizisi[:, 0]  # Tüm mağazaların ilk ay satışları
son_ay = satis_dizisi[:, 2]  # Tüm mağazaların son ay satışları
buyume_orani = (son_ay - ilk_ay) / ilk_ay * 100

print(f"Mağaza büyüme oranları (%): {buyume_orani}")

"""
AÇIKLAMALAR:
- axis=0: Sütunlar boyunca işlem (her ayın toplamı)
- axis=1: Satırlar boyunca işlem (her mağazanın toplamı)
- [:, 0]: Tüm satırlar, 0. sütun - ilk ay satışları
- [:, 2]: Tüm satırlar, 2. sütun - son ay satışları
- Broadcasting: İki dizi arasında otomatik boyut uyumlama
"""

import numpy as np

# Gerçek hayat senaryosu: Market ürün stok takibi
print("\n=== ÖRNEK 5: Ürün Stok Takibi ===")

# 4 farklı ürünün 5 farklı şubedeki stok miktarları
stok_verisi = [
    [50, 30, 25, 40, 35],  # Ürün A
    [20, 15, 10, 25, 18],  # Ürün B
    [100, 80, 60, 90, 70], # Ürün C
    [35, 28, 22, 30, 26]   # Ürün D
]

stok_dizisi = np.array(stok_verisi)
print(f"Stok verisi (4 ürün x 5 şube):\n{stok_dizisi}")

# Stok alarmı: Minimum stok seviyesi 20
min_stok_seviyesi = 20
dusuk_stoklar = stok_dizisi < min_stok_seviyesi

print(f"Düşük stok alarm matrisi:\n{dusuk_stoklar}")

# Hangi ürün-şube kombinasyonlarında stok alarmı var?
alarm_pozisyonlari = np.where(dusuk_stoklar)
print(f"Alarm pozisyonları: {list(zip(alarm_pozisyonlari[0], alarm_pozisyonlari[1]))}")

# Toplam stok maliyeti (ürün başına birim fiyat)
birim_fiyatlar = np.array([15.50, 8.75, 4.25, 12.30])  # TL
toplam_stok_maliyeti = np.sum(stok_dizisi * birim_fiyatlar[:, np.newaxis])

print(f"Birim fiyatlar: {birim_fiyatlar} TL")
print(f"Toplam stok maliyeti: {toplam_stok_maliyeti:.2f} TL")

"""
AÇIKLAMALAR:
- < operatörü: Element-wise karşılaştırma (her eleman için True/False)
- np.where(): Koşulu sağlayan elemanların indekslerini döndürür
- birim_fiyatlar[:, np.newaxis]: (4,) → (4,1) boyutuna çevirir (broadcasting için)
- * operatörü: Element-wise çarpım (her stok miktarı × birim fiyat)
"""

import numpy as np

# Gerçek hayat senaryosu: Fitness uygulaması adım verisi
print("\n=== ÖRNEK 6: Fitness Takip Analizi ===")

# 4 haftalık günlük adım sayıları
gunluk_adimlar = np.array([
    [8523, 9234, 7845, 9567, 10234, 11245, 9876],   # Hafta 1
    [9123, 8456, 9234, 8765, 9543, 10345, 8987],    # Hafta 2
    [7654, 8234, 8945, 9345, 8765, 9678, 10234],    # Hafta 3
    [9234, 8567, 9123, 9456, 9876, 10567, 9234]     # Hafta 4
])

print(f"4 haftalık adım verisi:\n{gunluk_adimlar}")

# Haftalık ortalama adımlar
haftalik_ortalama = np.mean(gunluk_adimlar, axis=1)
print(f"Haftalık ortalama adımlar: {haftalik_ortalama.astype(int)}")

# Günlük hedef: 10,000 adım
hedef_adim = 10000
hedef_tutan_gunler = gunluk_adimlar >= hedef_adim
hedef_orani = np.mean(hedef_tutan_gunler) * 100

print(f"Hedefi tutan günler:\n{hedef_tutan_gunler}")
print(f"Hedef tutma oranı: %{hedef_orani:.1f}")

# En aktif günler (hafta sonları: 5. ve 6. indeksler)
hafta_sonu_adimlari = gunluk_adimlar[:, [5, 6]]  # Cumartesi ve Pazar
hafta_ici_adimlari = gunluk_adimlar[:, :5]       # Pazartesi-Cuma

ortalama_hafta_sonu = np.mean(hafta_sonu_adimlari)
ortalama_hafta_ici = np.mean(hafta_ici_adimlari)

print(f"Ortalama hafta sonu adımı: {ortalama_hafta_sonu:.0f}")
print(f"Ortalama hafta içi adımı: {ortalama_hafta_ici:.0f}")

"""
AÇIKLAMALAR:
- axis=1: Satırlar boyunca ortalama (her haftanın ortalaması)
- astype(int): Ondalıklı sayıları tam sayıya çevirir
- [:, [5,6]]: Tüm satırlar, 5. ve 6. sütunlar (hafta sonları)
- [:, :5]: Tüm satırlar, ilk 5 sütun (hafta içi)
- Boolean dizilerde np.mean(): True=1, False=0 olarak hesaplar
"""

import numpy as np

# Gerçek hayat senaryosu: Aylık elektrik tüketim analizi
print("\n=== ÖRNEK 7: Enerji Tüketim Analizi ===")

# 12 aylık elektrik tüketimi (kWh)
aylik_tuketim = np.array([450, 420, 380, 350, 320, 300,
                         350, 380, 400, 430, 460, 480])

print(f"Aylık tüketim (kWh): {aylik_tuketim}")

# Mevsimsel analiz
kis_tuketim = aylik_tuketim[[0, 1, 10, 11]]  # Ocak, Şubat, Kasım, Aralık
yaz_tuketim = aylik_tuketim[5:8]             # Haziran, Temmuz, Ağustos

ortalama_kis = np.mean(kis_tuketim)
ortalama_yaz = np.mean(yaz_tuketim)

print(f"Kış ayları tüketimi: {kis_tuketim}")
print(f"Yaz ayları tüketimi: {yaz_tuketim}")
print(f"Ortalama kış tüketimi: {ortalama_kis:.1f} kWh")
print(f"Ortalama yaz tüketimi: {ortalama_yaz:.1f} kWh")

# Tüketim trend analizi
aylik_degisim = (aylik_tuketim[1:] - aylik_tuketim[:-1]) / aylik_tuketim[:-1] * 100
print(f"Aylık değişim oranları (%): {aylik_degisim}")

# Anomalı tüketim tespiti (ortalama ± 2 standart sapma)
ortalama = np.mean(aylik_tuketim)
std_sapma = np.std(aylik_tuketim)
ust_sinir = ortalama + 2 * std_sapma
alt_sinir = ortalama - 2 * std_sapma

anomaliler = (aylik_tuketim > ust_sinir) | (aylik_tuketim < alt_sinir)
print(f"Anomalı aylar: {np.where(anomaliler)[0] + 1}")  # +1 çünkü aylar 1'den başlar

"""
AÇIKLAMALAR:
- [0, 1, 10, 11]: Fancy indexing - belirli indeksleri seçer
- 5:8: Dilimleme - 5, 6, 7. indeksleri seçer (8 dahil değil)
- | operatörü: Boolean OR işlemi
- np.where()[0]: Koşulu sağlayan indeksleri döndürür
"""

import numpy as np

# Gerçek hayat senaryosu: Müşteri harcama alışkanlıkları analizi
print("\n=== ÖRNEK 8: Müşteri Segmentasyonu ===")

# 8 müşterinin 3 aylık harcama verileri (TL)
musteri_harcamalari = np.array([
    [1200, 1500, 1800],  # Müşteri 1
    [800, 950, 1100],    # Müşteri 2
    [2500, 2800, 3000],  # Müşteri 3
    [600, 700, 850],     # Müşteri 4
    [1800, 2000, 2200],  # Müşteri 5
    [950, 1200, 1400],   # Müşteri 6
    [3000, 3200, 3500],  # Müşteri 7
    [750, 800, 900]      # Müşteri 8
])

print(f"Müşteri harcama verisi:\n{musteri_harcamalari}")

# Boolean indexing ile müşteri segmentasyonu
vip_esik = 2500  # VIP müşteri eşiği
vip_musteriler = musteri_harcamalari[:, -1] > vip_esik  # Son ay harcaması
print(f"VIP müşteri maskesi: {vip_musteriler}")

# VIP müşterilerin verilerini seç
vip_verisi = musteri_harcamalari[vip_musteriler]
print(f"VIP müşteri verisi:\n{vip_verisi}")

# Büyüme potansiyeli olan müşteriler (her ay artan harcama)
artis_musteriler = np.all(musteri_harcamalari[:, 1:] > musteri_harcamalari[:, :-1], axis=1)
print(f"Büyüme müşterileri: {artis_musteriler}")

# Tüm segmentleri birleştir
segmentler = np.zeros(len(musteri_harcamalari), dtype='<U10')  # String dizi
segmentler[vip_musteriler] = 'VIP'
segmentler[artis_musteriler & ~vip_musteriler] = 'Büyüyor'
segmentler[~(vip_musteriler | artis_musteriler)] = 'Standart'

print(f"Müşteri segmentleri: {segmentler}")

"""
AÇIKLAMALAR:
- [:, -1]: Tüm müşterilerin son ay harcamaları
- [vip_musteriler]: Boolean indexing - True olan satırları seçer
- np.all(axis=1): Satır bazında tüm koşulların True olup olmadığını kontrol eder
- & ve |: Boolean AND/OR operatörleri
- ~: Boolean NOT operatörü
- dtype='<U10': Maksimum 10 karakterli Unicode string
"""

import numpy as np

# Gerçek hayat senaryosu: E-ticaret ürün özellik analizi
print("\n=== ÖRNEK 9: Ürün Özellik Matrisi İşleme ===")

# 6 ürünün 4 özelliği (fiyat, değerlendirme, stok, ağırlık)
urun_ozellikleri = np.array([
    [299.99, 4.5, 50, 1.2],   # Ürün A
    [149.50, 4.2, 25, 0.8],   # Ürün B
    [599.99, 4.8, 10, 3.5],   # Ürün C
    [79.99, 3.9, 100, 0.5],   # Ürün D
    [399.99, 4.6, 15, 2.1],   # Ürün E
    [199.99, 4.0, 40, 1.5]    # Ürün F
])

print(f"Ürün özellik matrisi:\n{urun_ozellikleri}")

# Fancy indexing ile belirli ürünleri seç
populer_urunler = [0, 2, 4]  # En popüler ürünlerin indeksleri
populer_verisi = urun_ozellikleri[populer_urunler]
print(f"Popüler ürünler:\n{populer_verisi}")

# Belirli özelliklere göre sıralama (değerlendirmeye göre azalan)
siralama_indeksleri = np.argsort(urun_ozellikleri[:, 1])[::-1]  # Değerlendirme sütunu
siralanmis_urunler = urun_ozellikleri[siralama_indeksleri]

print(f"Değerlendirmeye göre sıralanmış ürünler:\n{siralanmis_urunler}")

# Çoklu koşullu filtreleme (fiyat < 300 ve değerlendirme > 4.0)
uygun_urunler = (urun_ozellikleri[:, 0] < 300) & (urun_ozellikleri[:, 1] > 4.0)
secilen_urunler = urun_ozellikleri[uygun_urunler]

print(f"Uygun ürünler (fiyat < 300, değerlendirme > 4.0):\n{secilen_urunler}")

"""
AÇIKLAMALAR:
- [populer_urunler]: Fancy indexing - belirli satırları seçer
- np.argsort(): Sıralanmış indeksleri döndürür
- [::-1]: Diziyi ters çevirir (azalan sıra için)
- [:, 0] ve [:, 1]: Belirli sütunları seçer
- Çoklu koşullar: Parantezler önemli!
"""

import numpy as np

# Gerçek hayat senaryosu: Sensör verisini yeniden yapılandırma
print("\n=== ÖRNEK 10: Zaman Serisi Yeniden Şekillendirme ===")

# 30 günlük günlük sıcaklık ölçümleri (düz liste)
duz_veri = np.array([
    22.5, 23.1, 21.8, 24.2, 25.6, 26.8, 27.3, 26.5, 25.2, 23.8,
    22.1, 21.5, 20.8, 22.3, 24.7, 26.1, 27.8, 28.2, 27.5, 26.3,
    24.9, 23.4, 22.7, 21.9, 23.2, 25.4, 26.9, 28.1, 29.3, 28.7
])

print(f"Düz veri boyutu: {duz_veri.shape}")

# Veriyi haftalık formata çevir (4 hafta x 7 gün)
haftalik_veri = duz_veri.reshape(4, 7)
print(f"Haftalık veri (4 hafta x 7 gün):\n{haftalik_veri}")

# Hafta sonu ve hafta içi analizi
hafta_sonu_verisi = haftalik_veri[:, [5, 6]]  # Cumartesi ve Pazar
hafta_ici_verisi = haftalik_veri[:, :5]       # Pazartesi-Cuma

print(f"Hafta sonu verisi:\n{hafta_sonu_verisi}")
print(f"Hafta içi verisi:\n{hafta_ici_verisi}")

# Transpoz: Günler satır, haftalar sütun olacak şekilde
transpoz_veri = haftalik_veri.T
print(f"Transpoz veri (7 gün x 4 hafta):\n{transpoz_veri}")

# Belirli bir haftanın verisini seç ve işle
ikinci_hafta = haftalik_veri[1, :]  # 2. haftanın tüm günleri
print(f"2. hafta verisi: {ikinci_hafta}")

# VIEW vs COPY örneği
view_veri = haftalik_veri[0:2, :]    # VIEW - orijinal veriyi paylaşır
copy_veri = haftalik_veri[0:2, :].copy()  # COPY - yeni bellek alanı

print(f"View base: {view_veri.base is haftalik_veri}")  # True
print(f"Copy base: {copy_veri.base is haftalik_veri}")  # False

"""
AÇIKLAMALAR:
- reshape(4, 7): 30 elemanlı diziyi 4x7 matrise çevirir
- [:, [5,6]]: Tüm satırlar, 5. ve 6. sütunlar
- .T: Transpoz işlemi (satır↔sütun)
- [1, :]: 1. satırın tüm sütunları
- .base: Dizinin view mi copy mi olduğunu kontrol eder
"""

import numpy as np

# Gerçek hayat senaryosu: 3 boyutlu depo stok takibi
print("\n=== ÖRNEK 11: Çok Boyutlu Stok Takip Sistemi ===")

# 3 depo x 4 raf x 6 bölüm stok verisi
depo_stoklari = np.random.randint(0, 100, size=(3, 4, 6))
print(f"Depo stok verisi boyutu: {depo_stoklari.shape}")
print(f"Depo 0 stokları:\n{depo_stoklari[0]}")

# Belirli bir deponun tüm stoklarını seç
depo_1_stok = depo_stoklari[1, :, :]  # 1. deponun tüm raf ve bölümleri
print(f"Depo 1 stokları:\n{depo_1_stok}")

# Tüm depoların belirli bir rafındaki stoklar
raf_2_stok = depo_stoklari[:, 2, :]  # Tüm depoların 2. rafı
print(f"Raf 2 stokları (tüm depolar):\n{raf_2_stok}")

# Çoklu indeksleme ile karmaşık seçim
ozel_secim = depo_stoklari[[0, 2], 1:3, [2, 4, 5]]
print(f"Özel seçim (depo 0,2; raf 1,2; bölüm 2,4,5):\n{ozel_secim}")

# Stok azlığı tespiti
dusuk_stok_esigi = 20
dusuk_stoklar = depo_stoklari < dusuk_stok_esigi
dusuk_stok_sayisi = np.sum(dusuk_stoklar)

print(f"Düşük stok sayısı: {dusuk_stok_sayisi}")
print(f"Düşük stok pozisyonları: {np.where(dusuk_stoklar)}")

"""
AÇIKLAMALAR:
- (3, 4, 6): 3 depo, her depoda 4 raf, her rafta 6 bölüm
- [1, :, :]: 1. depo, tüm raflar, tüm bölümler
- [:, 2, :]: Tüm depolar, 2. raf, tüm bölümler
- [[0,2], 1:3, [2,4,5]]: Fancy indexing + dilimleme kombinasyonu
- np.where(): Çok boyutlu dizilerde koordinatları döndürür
"""

import numpy as np

# Gerçek hayat senaryosu: Çalışan maaş bordrosu hesaplama
print("\n=== ÖRNEK 12: Maaş Bordro Hesaplama Sistemi ===")

# 8 çalışanın temel maaş, prim, mesai verileri
calisan_verisi = np.array([
    [8500, 1200, 15],   # Çalışan 1
    [7200, 800, 8],     # Çalışan 2
    [9500, 1500, 20],   # Çalışan 3
    [6800, 600, 5],     # Çalışan 4
    [7800, 1000, 12],   # Çalışan 5
    [9200, 1300, 18],   # Çalışan 6
    [7500, 900, 10],    # Çalışan 7
    [8800, 1100, 14]    # Çalışan 8
])

print(f"Çalışan verisi (temel maaş, prim, mesai saati):\n{calisan_verisi}")

# Net maaş hesaplama (temel + prim + mesai*50 - vergi)
mesai_ucreti = 50
vergi_orani = 0.15

temel_maas = calisan_verisi[:, 0]
prim = calisan_verisi[:, 1]
mesai_saati = calisan_verisi[:, 2]

brut_maas = temel_maas + prim + (mesai_saati * mesai_ucreti)
vergi = brut_maas * vergi_orani
net_maas = brut_maas - vergi

print(f"Brüt maaşlar: {brut_maas}")
print(f"Vergiler: {vergi}")
print(f"Net maaşlar: {net_maas}")

# Maaş bandı analizi
maas_bandlari = [0, 8000, 10000, 15000, np.inf]
band_etiketleri = ['Düşük', 'Orta', 'Yüksek', 'Çok Yüksek']

for i, maas in enumerate(brut_maas):
    for j in range(len(maas_bandlari)-1):
        if maas_bandlari[j] <= maas < maas_bandlari[j+1]:
            print(f"Çalışan {i+1}: {maas:.0f} TL → {band_etiketleri[j]} band")
            break

"""
AÇIKLAMALAR:
- [:, 0], [:, 1], [:, 2]: Sütun bazlı veri seçimi
- Element-wise operasyonlar: Tüm diziler aynı anda işlenir
- np.inf: Sonsuzluk, üst sınır için kullanılır
- enumerate(): Hem indeks hem değer için kullanışlı
"""

import numpy as np

# Gerçek hayat senaryosu: Üretim hattı kalite kontrolü
print("\n=== ÖRNEK 13: Kalite Kontrol Veri Analizi ===")

# 5 makinenin 10 günlük hata sayıları
hata_verisi = np.array([
    [2, 1, 0, 3, 2, 1, 0, 2, 1, 2],  # Makine 1
    [5, 4, 6, 3, 5, 4, 5, 6, 4, 5],  # Makine 2
    [1, 0, 1, 2, 0, 1, 1, 0, 2, 1],  # Makine 3
    [3, 2, 4, 3, 2, 3, 4, 3, 2, 3],  # Makine 4
    [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]   # Makine 5
])

print(f"Hata verisi (5 makine x 10 gün):\n{hata_verisi}")

# Boolean indexing ile problemli günleri bul
kritik_esik = 4
problemli_gunler = hata_verisi > kritik_esik
print(f"Problemli günler (hata > {kritik_esik}):\n{problemli_gunler}")

# Her makinenin problemli gün sayısı
makine_problem_sayisi = np.sum(problemli_gunler, axis=1)
print(f"Makine problem sayıları: {makine_problem_sayisi}")

# En problemli makineyi bul
en_problemli_makine = np.argmax(makine_problem_sayisi)
print(f"En problemli makine: {en_problemli_makine + 1}")

# Hareketli ortalama ile trend analizi (3 günlük)
def hareketli_ortalama(dizi, pencere):
    return np.convolve(dizi, np.ones(pencere)/pencere, mode='valid')

makine_2_trend = hareketli_ortalama(hata_verisi[1], 3)
print(f"Makine 2 hareketli ortalama (3 gün): {makine_2_trend}")

"""
AÇIKLAMALAR:
- > operatörü: Element-wise büyüktür karşılaştırması
- np.sum(axis=1): Satırlar boyunca toplam (her makinenin problem sayısı)
- np.argmax(): Maksimum değerin indeksini döndürür
- np.convolve(): Konvolüsyon ile hareketli ortalama hesaplar
- mode='valid': Kenar efektleri olmadan geçerli pencereler
"""

import numpy as np

# Gerçek hayat senaryosu: Müşteri memnuniyet anketi analizi
print("\n=== ÖRNEK 14: Müşteri Memnuniyet Anketi ===")

# 20 müşterinin 5 soruya verdiği puanlar (1-5 arası)
anket_verisi = np.array([
    [5, 4, 3, 5, 4], [4, 3, 4, 4, 3], [5, 5, 5, 5, 5], [2, 3, 2, 3, 2],
    [4, 4, 4, 4, 4], [3, 3, 4, 3, 3], [5, 4, 5, 4, 5], [1, 2, 1, 2, 1],
    [4, 5, 4, 5, 4], [3, 4, 3, 4, 3], [5, 4, 4, 5, 4], [2, 2, 3, 2, 2],
    [4, 4, 5, 4, 4], [3, 3, 3, 3, 3], [5, 5, 4, 5, 5], [4, 3, 4, 3, 4],
    [3, 4, 3, 4, 3], [5, 4, 5, 4, 5], [2, 3, 2, 3, 2], [4, 4, 4, 4, 4]
])

print(f"Anket verisi (20 müşteri x 5 soru):\n{anket_verisi}")

# Soru bazında ortalama puanlar
soru_ortalamalari = np.mean(anket_verisi, axis=0)
print(f"Soru ortalamaları: {soru_ortalamalari}")

# Müşteri bazında toplam puanlar
musteri_toplamlari = np.sum(anket_verisi, axis=1)
print(f"Müşteri toplam puanları: {musteri_toplamlari}")

# Memnun müşterileri belirle (toplam puan >= 20)
memnun_musteriler = musteri_toplamlari >= 20
memnun_orani = np.mean(memnun_musteriler) * 100

print(f"Memnun müşteri sayısı: {np.sum(memnun_musteriler)}")
print(f"Memnuniyet oranı: %{memnun_orani:.1f}")

# En düşük puan alan soruyu bul
en_kotu_soru = np.argmin(soru_ortalamalari)
print(f"En düşük puan alan soru: {en_kotu_soru + 1} (ortalama: {soru_ortalamalari[en_kotu_soru]:.2f})")

"""
AÇIKLAMALAR:
- axis=0: Sütunlar boyunca ortalama (her sorunun ortalaması)
- axis=1: Satırlar boyunca toplam (her müşterinin toplam puanı)
- >= operatörü: Boolean dizi oluşturur
- np.argmin(): Minimum değerin indeksini döndürür
- Boolean dizide np.mean(): True oranını hesaplar
"""

import numpy as np

# Gerçek hayat senaryosu: Portföy risk analizi
print("\n=== ÖRNEK 15: Finansal Risk Analizi ===")

# 5 farklı hisse senedinin 30 günlük getiri oranları (%)
getiri_verisi = np.random.normal(0.1, 2, size=(5, 30))  # Ortalama %0.1, std %2
print(f"Getiri verisi (5 hisse x 30 gün):\n{getiri_verisi}")

# Her hissenin ortalama getirisi ve volatilitesi
hisse_ortalamalari = np.mean(getiri_verisi, axis=1)
hisse_volatiliteleri = np.std(getiri_verisi, axis=1)

print(f"Hisse ortalamaları (%): {hisse_ortalamalari}")
print(f"Hisse volatiliteleri (%): {hisse_volatiliteleri}")

# Risk-getiri analizi: Sharpe Oranı (risk-free rate = %0.05)
risk_free_rate = 0.05
sharpe_oranlari = (hisse_ortalamalari - risk_free_rate) / hisse_volatiliteleri

print(f"Sharpe oranları: {sharpe_oranlari}")

# En iyi performans gösteren hisseyi bul
en_iyi_hisse = np.argmax(sharpe_oranlari)
print(f"En iyi performans gösteren hisse: {en_iyi_hisse + 1}")

# Korelasyon matrisi
korelasyon_matrisi = np.corrcoef(getiri_verisi)
print(f"Korelasyon matrisi:\n{korelasyon_matrisi}")

# Yüksek korelasyonlu hisse çiftlerini bul
yuksek_korelasyon_esigi = 0.7
yuksek_korelasyonlar = np.where((korelasyon_matrisi > yuksek_korelasyon_esihi) &
                               (korelasyon_matrisi < 1.0))  # 1.0'dan küçük (kendisiyle korelasyon değil)

print(f"Yüksek korelasyonlu hisse çiftleri: {list(zip(yuksek_korelasyonlar[0], yuksek_korelasyonlar[1]))}")

"""
AÇIKLAMALAR:
- np.random.normal(): Normal dağılımdan rastgele sayılar üretir
- axis=1: Satırlar boyunca istatistik (her hissenin istatistiği)
- Sharpe Oranı: Risk birimi başına getiriyi ölçer
- np.corrcoef(): Korelasyon matrisi hesaplar
- np.where() + koşul: Matriste koşulu sağlayan pozisyonları bulur
- zip(): İki listeyi çiftler halinde birleştirir
"""